#! /bin/sh
# Install modified versions of certain ANSI-incompatible
# native System V Release 4 system include files.
# Copyright (C) 1994, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
# Contributed by Ron Guilmette (rfg@monkeys.com).
#
# This file is part of GNU CC.
# 
# GNU CC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
# 
# GNU CC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GNU CC; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
#	This script munges the native include files provided with System V
#	Release 4 systems so as to remove things which are violations of the
#	ANSI C standard.  Once munged, the resulting new system include files
#	are placed in a directory that GNU C will search *before* searching
#	the /usr/include directory. This script should work properly for most
#	System V Release 4 systems.  For other types of systems, you should
#	use the `fixincludes' script instead.
#
#	See README-fixinc for more information.

# Fail if no arg to specify a directory for the output.
if [ x$1 = x ]
then echo fixincludes: no output directory specified
exit 1
fi

# Directory in which to store the results.
LIB=${1?"fixincludes: output directory not specified"}

# Make sure it exists.
if [ ! -d $LIB ]; then
  mkdir $LIB || exit 1
fi

ORIG_DIR=`${PWDCMD-pwd}`

# Make LIB absolute if it is relative.
# Don't do this if not necessary, since may screw up automounters.
case $LIB in
/*)
	;;
*)
 	cd $LIB; LIB=`${PWDCMD-pwd}`
	;;
esac

echo 'Building fixincludes in ' ${LIB}

# Determine whether this filesystem has symbolic links.
if ln -s X $LIB/ShouldNotExist 2>/dev/null; then
  rm -f $LIB/ShouldNotExist
  LINKS=true
else
  LINKS=false
fi

echo 'Making directories:'

# Directory containing the original header files.
shift
if [ $# -eq 0 ] ; then
  set /usr/include
fi

INLIST="$@"

for INPUT in ${INLIST} ; do
cd ${ORIG_DIR}
cd ${INPUT}

if $LINKS; then
  files=`find . -follow -type d -print 2>/dev/null | sed '/^.$/d'`
else
  files=`find . -type d -print | sed '/^.$/d'`
fi
for file in $files; do
  rm -rf $LIB/$file
  if [ ! -d $LIB/$file ]
  then mkdir $LIB/$file
  fi
done

# treetops gets an alternating list
# of old directories to copy
# and the new directories to copy to.
treetops="${INPUT} ${LIB}"

if $LINKS; then
  echo 'Making internal symbolic directory links'
  for file in $files; do
    dest=`ls -ld $file | sed -n 's/.*-> //p'`
    if [ "$dest" ]; then    
      cwd=`pwd`
      # In case $dest is relative, get to $file's dir first.
      cd ${INPUT}
      cd `echo ./$file | sed -n 's&[^/]*$&&p'`
      rwd=`pwd`
      # Check that the target directory exists.
      # Redirections changed to avoid bug in sh on Ultrix.
      (cd $dest) > /dev/null 2>&1
      if [ $? = 0 ]; then
	cd $dest
	# X gets the dir that the link actually leads to.
	x=`pwd`
	# If link leads back into ${INPUT},
	# make a similar link here.
        if expr "$dest" : '[^/][^/]*' >/dev/null && [ ! -h $dest ]; then
          echo $file '->'  $dest': Making link'
          rm -fr ${LIB}/$file > /dev/null 2>&1
          ln -s $dest ${LIB}/$file > /dev/null 2>&1
	elif expr $x : "${INPUT}/.*" > /dev/null; then
	  # Y gets the actual target dir name, relative to ${INPUT}.
	  y=`echo $x | sed -n "s&${INPUT}/&&p"`
	  # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.
	  dots=`echo "$file" |
	    sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`
	  echo $file '->' $dots$y ': Making link'
	  rm -fr ${LIB}/$file > /dev/null 2>&1
	  ln -s $dots$y ${LIB}/$file > /dev/null 2>&1
	elif expr $x : "${rwd}/.*" > /dev/null; then
	  # Y gets the actual target dir name, relative to the directory where the link is.
	  y=`echo $x | sed -n "s&${rwd}/&&p"`
	  # DOTS is the relative path from ${LIB}/$file's dir back to ${LIB}.
	  dots=`echo "$file" |
	    sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`
	  echo $file '->' $dots$y ': Making link'
	  rm -fr ${LIB}/$file > /dev/null 2>&1
	  ln -s $dots$y ${LIB}/$file > /dev/null 2>&1
	else
	  # If the link is to outside ${INPUT},
	  # treat this directory as if it actually contained the files.
# This line used to have $dest instead of $x.
# $dest seemed to be wrong for links found in subdirectories
# of ${INPUT}.  Does this change break anything?
	  treetops="$treetops $x ${LIB}/$file"
	fi
      fi
      cd $cwd
    fi
  done
fi

set - $treetops
while [ $# != 0 ]; do
  # $1 is an old directory to copy, and $2 is the new directory to copy to.
  echo "Finding header files in $1:"
  cd ${INPUT}
  cd $1
  files=`find . -name '*.h' -type f -print`
  echo 'Checking header files:'
  for file in $files; do
      if [ -r $file ]; then
	cp $file $2/$file >/dev/null 2>&1 || echo "Can't copy $file"
	chmod +w $2/$file
	chmod a+r $2/$file

# The following have been removed from the sed command below
# because it is more useful to leave these things in.
# The only reason to remove them was for -pedantic,
# which isn't much of a reason. -- rms.
#	  /^[ 	]*#[ 	]*ident/d

# This code makes Solaris SCSI fail, because it changes the
# alignment within some critical structures.  See <sys/scsi/impl/commands.h>.
#	  s/u_char\([ 	][ 	]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ 	]*:[ 	]*[0-9][0-9]*\)/u_int\1/
# Disable these also, since they probably aren't safe either.
#	  s/u_short\([ 	][ 	]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ 	]*:[ 	]*[0-9][0-9]*\)/u_int\1/
#	  s/ushort\([ 	][ 	]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ 	]*:[ 	]*[0-9][0-9]*\)/u_int\1/
#	  s/evcm_t\([ 	][ 	]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ 	]*:[ 	]*[0-9][0-9]*\)/u_int\1/
#	  s/Pbyte\([ 	][ 	]*[a-zA-Z0-9_][a-zA-Z0-9_]*[ 	]*:[ 	]*SEQSIZ\)/unsigned int\1/

# The change of u_char, etc, to u_int
# applies to bit fields.
	sed -e '
	  s%^\([ 	]*#[ 	]*else\)[ 	]*/[^*].*%\1%
	  s%^\([ 	]*#[ 	]*else\)[ 	]*[^/ 	].*%\1%
	  s%^\([ 	]*#[ 	]*endif\)[ 	]*/[^*].*%\1%
	  s%^\([ 	]*#[ 	]*endif\)[ 	]*[^/ 	].*%\1%
  	  s/#lint(on)/defined(lint)/g
  	  s/#lint(off)/!defined(lint)/g
  	  s/#machine(\([^)]*\))/defined(__\1__)/g
  	  s/#system(\([^)]*\))/defined(__\1__)/g
  	  s/#cpu(\([^)]*\))/defined(__\1__)/g
	  /#[a-z]*if.*[	 (]m68k/		s/\([^_]\)m68k/\1__m68k__/g
	  /#[a-z]*if.*[	 (]__i386\([^_]\)/	s/__i386/__i386__/g
	  /#[a-z]*if.*[	 (]i386/		s/\([^_]\)i386/\1__i386__/g
	  /#[a-z]*if.*[	 (!]__i860\([^_]\)/	s/__i860/__i860__/g
	  /#[a-z]*if.*[	 (!]i860/		s/\([^_]\)i860/\1__i860__/g
	  /#[a-z]*if.*[	 (]sparc/	s/\([^_]\)sparc/\1__sparc__/g
	  /#[a-z]*if.*[	 (]mc68000/	s/\([^_]\)mc68000/\1__mc68000__/g
	  /#[a-z]*if.*[	 (]vax/		s/\([^_]\)vax/\1__vax__/g
	  /#[a-z]*if.*[	 (]sun/		s/\([^_]\)\(sun[a-z0-9]*\)\([^a-z0-9_]\)/\1__\2__\3/g
	  /#[a-z]*if.*[	 (]sun/		s/\([^_]\)\(sun[a-z0-9]*\)$/\1__\2__/g
	  /#[a-z]*if.*[	 (]ns32000/	s/\([^_]\)ns32000/\1__ns32000__/g
	  /#[a-z]*if.*[	 (]pyr/		s/\([^_]\)pyr/\1__pyr__/g
	  /#[a-z]*if.*[	 (]is68k/	s/\([^_]\)is68k/\1__is68k__/g
	  s/__STDC__[ 	][ 	]*==[ 	][ 	]*0/!defined (__STRICT_ANSI__)/g
	  s/__STDC__[ 	][ 	]*==[ 	][ 	]*1/defined (__STRICT_ANSI__)/g
	  s/__STDC__[ 	][ 	]*!=[ 	][ 	]*0/defined (__STRICT_ANSI__)/g
	  s/__STDC__[ 	][ 	]*!=[ 	][ 	]*1/!defined (__STRICT_ANSI__)/g
	  s/__STDC__ - 0 == 0/!defined (__STRICT_ANSI__)/g
	  s/__STDC__ - 0 == 1/defined (__STRICT_ANSI__)/g
	  /^typedef[ 	][ 	]*[unsigned 	]*long[ 	][ 	]*[u_]*longlong_t;/s/long/long long/
	' $2/$file > $2/$file.sed
	mv $2/$file.sed $2/$file
	if cmp $file $2/$file >/dev/null 2>&1; then
	   rm $2/$file
	else
	   echo Fixed $file
	fi
      fi
  done
  shift; shift
done

# Install the proper definition of the three standard types in header files
# that they come from.
for file in sys/types.h stdlib.h sys/stdtypes.h stddef.h memory.h unistd.h; do
  if [ -r $file ] && [ ! -r ${LIB}/$file ]; then
    cp $file ${LIB}/$file >/dev/null 2>&1 || echo "Can't copy $file"
    chmod +w ${LIB}/$file 2>/dev/null
    chmod a+r ${LIB}/$file 2>/dev/null
  fi

  if [ -r ${LIB}/$file ]; then
    echo Fixing size_t, ptrdiff_t and wchar_t in $file
    sed \
      -e '/typedef[ 	][ 	]*[a-z_][ 	a-z_]*[ 	]size_t/i\
#ifndef __SIZE_TYPE__\
#define __SIZE_TYPE__ long unsigned int\
#endif
' \
      -e 's/typedef[ 	][ 	]*[a-z_][ 	a-z_]*[ 	]size_t/typedef __SIZE_TYPE__ size_t/' \
      -e '/typedef[ 	][ 	]*[a-z_][ 	a-z_]*[ 	]ptrdiff_t/i\
#ifndef __PTRDIFF_TYPE__\
#define __PTRDIFF_TYPE__ long int\
#endif
' \
      -e 's/typedef[ 	][ 	]*[a-z_][ 	a-z_]*[ 	]ptrdiff_t/typedef __PTRDIFF_TYPE__ ptrdiff_t/' \
      -e '/typedef[ 	][ 	]*[a-z_][ 	a-z_]*[ 	]wchar_t/i\
#ifndef __WCHAR_TYPE__\
#define __WCHAR_TYPE__ int\
#endif
' \
      -e 's/typedef[ 	][ 	]*[a-z_][ 	a-z_]*[ 	]wchar_t/typedef __WCHAR_TYPE__ wchar_t/' \
      ${LIB}/$file > ${LIB}/${file}.sed
    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file
    if cmp $file ${LIB}/$file >/dev/null 2>&1; then
      rm ${LIB}/$file
    fi
  fi
done

# Fix first broken decl of getcwd present on some svr4 systems.

file=stdlib.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e 's/getcwd(char \*, int)/getcwd(char *, size_t)/' $file_to_fix > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Fix second broken decl of getcwd present on some svr4 systems.  Also
# fix the incorrect decl of profil present on some svr4 systems.

file=unistd.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e 's/getcwd(char \*, int)/getcwd(char *, size_t)/' $file_to_fix \
    | sed -e 's/profil(unsigned short \*, unsigned int, unsigned int, unsigned int)/profil(unsigned short *, size_t, int, unsigned)/' > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Fix the definition of NULL in <sys/param.h> so that it is conditional
# and so that it is correct for both C and C++.

file=sys/param.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  chmod a+r /tmp/$base
  sed -e '/^#define[ 	]*NULL[ 	]*0$/c\
#ifndef NULL\
#ifdef __cplusplus\
#define __NULL_TYPE\
#else /* !defined(__cplusplus) */\
#define __NULL_TYPE (void *)\
#endif /* !defined(__cplusplus) */\
#define NULL (__NULL_TYPE 0)\
#endif /* !defined(NULL) */' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Likewise fix the definition of NULL in <stdio.h> so that it is conditional
# and so that it is correct for both C and C++.

file=stdio.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/^#define[ 	]*NULL[ 	]*0$/c\
#ifdef __cplusplus\
#define __NULL_TYPE\
#else /* !defined(__cplusplus) */\
#define __NULL_TYPE (void *)\
#endif /* !defined(__cplusplus) */\
#define NULL (__NULL_TYPE 0)' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Likewise fix the definition of NULL in <dbm.h> so that it is conditional
# and so that it is correct for both C and C++.

file=dbm.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/^#define[ 	]*NULL[ 	]*((char \*) 0)$/c\
#ifndef NULL\
#ifdef __cplusplus\
#define __NULL_TYPE\
#else /* !defined(__cplusplus) */\
#define __NULL_TYPE (void *)\
#endif /* !defined(__cplusplus) */\
#define NULL (__NULL_TYPE 0)\
#endif /* !defined(NULL) */' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Add a prototyped declaration of mmap to <sys/mman.h>.

file=sys/mman.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/^extern caddr_t mmap();$/c\
#ifdef __STDC__\
extern caddr_t mmap (caddr_t, size_t, int, int, int, off_t);\
#else /* !defined(__STDC__) */\
extern caddr_t mmap ();\
#endif /* !defined(__STDC__) */' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Fix declarations of `ftw' and `nftw' in <ftw.h>.  On some/most SVR4 systems
# the file <ftw.h> contains extern declarations of these functions followed
# by explicitly `static' definitions of these functions... and that's not
# allowed according to ANSI C.  (Note however that on Solaris, this header
# file glitch has been pre-fixed by Sun.  In the Solaris version of <ftw.h>
# there are no static definitions of any function so we don't need to do
# any of this stuff when on Solaris.

file=ftw.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if test -z "$file_to_fix" || grep 'define	ftw' $file_to_fix > /dev/null; then
# Either we have no <ftw.h> file at all, or else we have the pre-fixed Solaris
# one.  Either way, we don't have to do anything.
  true
else
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/^extern int ftw(const/i\
#if !defined(_STYPES)\
static\
#else\
extern\
#endif
'\
  -e 's/extern \(int ftw(const.*\)$/\1/' \
  -e '/^extern int nftw/i\
#if defined(_STYPES)\
static\
#else\
extern\
#endif
'\
  -e 's/extern \(int nftw.*\)$/\1/' \
  -e '/^extern int ftw(),/c\
#if !defined(_STYPES)\
static\
#else\
extern\
#endif\
  int ftw();\
#if defined(_STYPES)\
static\
#else\
extern\
#endif\
  int nftw();' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Avoid the definition of the bool type in the Solaris 2.x curses.h when using
# g++, since it's now an official type in the C++ language.
file=curses.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi

if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e 's,^typedef[ 	]char[ 	]bool;$,#ifndef __cplusplus\
typedef	char bool;\
#endif /* !defined __cplusplus */,' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Add a `static' declaration of `getrnge' into <regexp.h>.

# Don't do this if there is already a `static void getrnge' declaration
# present, since this would cause a redeclaration error.  Solaris 2.x has
# such a declaration.

file=regexp.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep "static void getrnge" $file_to_fix > /dev/null; then
    true
  else
    cp $file_to_fix /tmp/$base
    chmod +w /tmp/$base
    sed -e '/^static int[ 	]*size;/c\
static int	size ;\
\
static int getrnge ();' /tmp/$base > /tmp/$base.sed
    if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
      true
    else
      echo Fixed $file_to_fix
      rm -f ${LIB}/$file
      cp /tmp/$base.sed ${LIB}/$file
      chmod a+r ${LIB}/$file
    fi
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Disable apparent native compiler optimization cruft in SVR4.2 <string.h>
# that is visible to any ANSI compiler using this include.  Simply
# delete the lines that #define some string functions to internal forms.

file=string.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/#define.*__std_hdr_/d' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Delete any #defines of `__i386' which may be present in <ieeefp.h>.  They
# tend to conflict with the compiler's own definition of this symbol.  (We
# will use the compiler's definition.)
# Likewise __sparc, for Solaris, and __i860, and a few others
# (guessing it is necessary for all of them).

file=ieeefp.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/#define[ 	]*__i386 /d' -e '/#define[ 	]*__sparc /d' \
      -e '/#define[ 	]*__i860 /d' -e '/#define[ 	]*__m88k /d' \
      -e '/#define[ 	]*__mips /d' -e '/#define[ 	]*__m68k /d' \
     /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix 
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file 
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed 
fi 

# Add a #define of _SIGACTION_ into <sys/signal.h>.
# Also fix types of SIG_DFL, SIG_ERR, SIG_IGN, and SIG_HOLD.

file=sys/signal.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/^struct sigaction {/c\
#define _SIGACTION_\
struct  sigaction  {' \
  -e '1,$s/(void *(\*)())/(void (*)(int))/' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Fix declarations of `makedev', `major', and `minor' in <sys/mkdev.h>.

file=sys/mkdev.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/^dev_t makedev(const/c\
static dev_t makedev(const major_t, const minor_t);' \
  -e '/^dev_t makedev()/c\
static dev_t makedev();' \
  -e '/^major_t major(const/c\
static major_t major(const dev_t);' \
  -e '/^major_t major()/c\
static major_t major();' \
  -e '/^minor_t minor(const/c\
static minor_t minor(const dev_t);' \
  -e '/^minor_t minor()/c\
static minor_t minor();' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Fix reference to NMSZ in <sys/adv.h>.

file=sys/adv.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed 's/\[NMSZ\]/\[RFS_NMSZ\]/g' $file_to_fix > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Fix reference to NC_NPI_RAW in <sys/netcspace.h>.  Also fix types of
# array initializers.

file=sys/netcspace.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed 's/NC_NPI_RAW/NC_TPI_RAW/g' $file_to_fix \
    | sed 's/NC_/(unsigned long) NC_/' > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Conditionalize all of <fs/rfs/rf_cache.h> on _KERNEL being defined.

file=fs/rfs/rf_cache.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize all of <sys/erec.h> on _KERNEL being defined.

file=sys/erec.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize all of <sys/err.h> on _KERNEL being defined.

file=sys/err.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize all of <sys/char.h> on _KERNEL being defined.

file=sys/char.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize all of <sys/getpages.h> on _KERNEL being defined.

file=sys/getpages.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize all of <sys/map.h> on _KERNEL being defined.

file=sys/map.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize all of <sys/cmn_err.h> on _KERNEL being defined.

file=sys/cmn_err.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize all of <sys/kdebugger.h> on _KERNEL being defined.

file=sys/kdebugger.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep _KERNEL $file_to_fix > /dev/null; then
    true
  else
    echo '#ifdef _KERNEL' > /tmp/$base
    cat $file_to_fix >> /tmp/$base
    echo '#endif /* defined(_KERNEL) */' >> /tmp/$base
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
    rm -f /tmp/$base
  fi
fi

# Conditionalize some of <netinet/in.h> on _KERNEL being defined.
# This has been taken out because it breaks on some versions of
# DYNIX/ptx, and it does not seem to do much good on any system.
# file=netinet/in.h
# base=`basename $file`.$$
# if [ -r ${LIB}/$file ]; then
#   file_to_fix=${LIB}/$file
# else
#   if [ -r ${INPUT}/$file ]; then
#     file_to_fix=${INPUT}/$file
#   else
#     file_to_fix=""
#   fi
# fi
# if [ \! -z "$file_to_fix" ]; then
#   echo Checking $file_to_fix
#   if grep _KERNEL $file_to_fix > /dev/null; then
#     true
#   else
#     sed -e '/#ifdef INKERNEL/i\
# #ifdef _KERNEL
# ' \
#     -e '/#endif[ 	]*\/\* INKERNEL \*\//a\
# #endif /* _KERNEL */
# ' \
#     $file_to_fix > ${LIB}/${file}.sed
#     rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file
#     echo Fixed $file_to_fix
#   fi
# fi

# Conditionalize some of <sys/endian.h> on __GNUC__ and __GNUG__.

file=sys/endian.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  if grep __GNUC__ $file_to_fix > /dev/null; then
    true
  else
    sed -e '/#	ifdef	__STDC__/i\
#   if !defined (__GNUC__) && !defined (__GNUG__)
' \
    -e '/#		include	<sys\/byteorder.h>/s/		/   /'\
    -e '/#   include	<sys\/byteorder.h>/i\
#   endif /* !defined (__GNUC__) && !defined (__GNUG__) */
'\
    $file_to_fix > ${LIB}/${file}.sed
    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file
    echo Fixed $file_to_fix
  fi
fi

# Commented out because tmcconne@sedona.intel.com says we don't clearly need it
# and the text in types.h is not erroneous.
## In sys/types.h, don't name the enum for booleans.
#
#file=sys/types.h
#base=`basename $file`.$$
#if [ -r ${LIB}/$file ]; then
#  file_to_fix=${LIB}/$file
#else
#  if [ -r ${INPUT}/$file ]; then
#    file_to_fix=${INPUT}/$file
#  else
#    file_to_fix=""
#  fi
#fi
#if [ \! -z "$file_to_fix" ]; then
#  echo Checking $file_to_fix
#  if grep "enum boolean" $file_to_fix > /dev/null; then
#    sed -e 's/enum boolean/enum/' ${LIB}/$file > ${LIB}/${file}.sed
#    rm -f ${LIB}/$file; mv ${LIB}/${file}.sed ${LIB}/$file
#    echo Fixed $file_to_fix
#  else
#    true
#  fi
#fi

# Remove useless extern keyword from struct forward declarations in
# <sys/stream.h> and <sys/strsubr.h>

file=sys/stream.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '
    s/extern struct stdata;/struct stdata;/g
    s/extern struct strevent;/struct strevent;/g
  ' $file_to_fix > /tmp/$base 
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

file=sys/strsubr.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '
    s/extern struct strbuf;/struct strbuf;/g
    s/extern struct uio;/struct uio;/g
    s/extern struct thread;/struct thread;/g
    s/extern struct proc;/struct proc;/g
  ' $file_to_fix > /tmp/$base 
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Put storage class at start of decl, to avoid warning.
file=rpc/types.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '
    s/const extern/extern const/g
  ' $file_to_fix > /tmp/$base 
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Convert functions to prototype form, and fix arg names in <sys/stat.h>.

file=sys/stat.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  cp $file_to_fix /tmp/$base
  chmod +w /tmp/$base
  sed -e '/^stat([ 	]*[^c]/{
N
N
s/(.*)\n/( /
s/;\n/, /
s/;$/)/
}' \
  -e '/^lstat([ 	]*[^c]/{
N
N
s/(.*)\n/( /
s/;\n/, /
s/;$/)/
}' \
  -e '/^fstat([ 	]*[^i]/{
N
N
s/(.*)\n/( /
s/;\n/, /
s/;$/)/
}' \
  -e '/^mknod([ 	]*[^c]/{
N
N
N
s/(.*)\n/( /
s/;\n/, /g
s/;$/)/
}' \
  -e '1,$s/\([^A-Za-z]\)path\([^A-Za-z]\)/\1__path\2/g' \
  -e '1,$s/\([^A-Za-z]\)buf\([^A-Za-z]\)/\1__buf\2/g' \
  -e '1,$s/\([^A-Za-z]\)fd\([^A-Za-z]\)/\1__fd\2/g' \
  -e '1,$s/ret\([^u]\)/__ret\1/g' \
  -e '1,$s/\([^_]\)mode\([^_]\)/\1__mode\2/g' \
  -e '1,$s/\([^_r]\)dev\([^_]\)/\1__dev\2/g' /tmp/$base > /tmp/$base.sed
  if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base.sed ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base /tmp/$base.sed
fi

# Sony NEWSOS 5.0 does not support the complete ANSI C standard.

if [ -x /bin/sony ]; then
  if /bin/sony; then

    # Change <stdio.h> to not define __filbuf, __flsbuf, and __iob

    file=stdio.h
    base=`basename $file`.$$
    if [ -r ${LIB}/$file ]; then
      file_to_fix=${LIB}/$file
    else
      if [ -r ${INPUT}/$file ]; then
        file_to_fix=${INPUT}/$file
      else
        file_to_fix=""
      fi
    fi
    if [ \! -z "$file_to_fix" ]; then
      echo Checking $file_to_fix
      cp $file_to_fix /tmp/$base
      chmod +w /tmp/$base
      sed -e '
        s/__filbuf/_filbuf/g
        s/__flsbuf/_flsbuf/g
        s/__iob/_iob/g
      ' /tmp/$base > /tmp/$base.sed
      mv /tmp/$base.sed /tmp/$base
      if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then
        true
      else
        echo Fixed $file_to_fix
        rm -f ${LIB}/$file
        cp /tmp/$base ${LIB}/$file
        chmod a+r ${LIB}/$file
      fi
      rm -f /tmp/$base
    fi

    # Change <ctype.h> to not define __ctype

    file=ctype.h
    base=`basename $file`.$$
    if [ -r ${LIB}/$file ]; then
      file_to_fix=${LIB}/$file
    else
      if [ -r ${INPUT}/$file ]; then
        file_to_fix=${INPUT}/$file
      else
        file_to_fix=""
      fi
    fi
    if [ \! -z "$file_to_fix" ]; then
      echo Checking $file_to_fix
      cp $file_to_fix /tmp/$base
      chmod +w /tmp/$base
      sed -e '
        s/__ctype/_ctype/g
      ' /tmp/$base > /tmp/$base.sed
      mv /tmp/$base.sed /tmp/$base
      if cmp $file_to_fix /tmp/$base.sed >/dev/null 2>&1; then
        true
      else
        echo Fixed $file_to_fix
        rm -f ${LIB}/$file
        cp /tmp/$base ${LIB}/$file
        chmod a+r ${LIB}/$file
      fi
      rm -f /tmp/$base
    fi
  fi
fi

# In limits.h, put #ifndefs around things that are supposed to be defined
# in float.h to avoid redefinition errors if float.h is included first.
# Solaris 2.1 has this problem.

file=limits.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '/[ 	]FLT_MIN[ 	]/i\
#ifndef FLT_MIN
'\
      -e '/[ 	]FLT_MIN[ 	]/a\
#endif
'\
      -e '/[ 	]FLT_MAX[ 	]/i\
#ifndef FLT_MAX
'\
      -e '/[ 	]FLT_MAX[ 	]/a\
#endif
'\
      -e '/[ 	]FLT_DIG[ 	]/i\
#ifndef FLT_DIG
'\
      -e '/[ 	]FLT_DIG[ 	]/a\
#endif
'\
      -e '/[ 	]DBL_MIN[ 	]/i\
#ifndef DBL_MIN
'\
      -e '/[ 	]DBL_MIN[ 	]/a\
#endif
'\
      -e '/[ 	]DBL_MAX[ 	]/i\
#ifndef DBL_MAX
'\
      -e '/[ 	]DBL_MAX[ 	]/a\
#endif
'\
      -e '/[ 	]DBL_DIG[ 	]/i\
#ifndef DBL_DIG
'\
      -e '/[ 	]DBL_DIG[ 	]/a\
#endif
' $file_to_fix > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Completely replace <sys/varargs.h> with a file that includes gcc's
# stdarg.h or varargs.h files as appropriate.

file=sys/varargs.h
if [ -r ${INPUT}/$file ]; then
  echo Replacing $file
  cat > ${LIB}/$file << EOF
/* This file was generated by fixincludes.  */
#ifndef _SYS_VARARGS_H
#define _SYS_VARARGS_H

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#endif  /* _SYS_VARARGS_H */
EOF
  chmod a+r ${LIB}/$file
fi

# In math.h, put #ifndefs around things that might be defined in a gcc
# specific math-*.h file.

file=math.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '/define[ 	]HUGE_VAL[ 	]/i\
#ifndef HUGE_VAL
'\
      -e '/define[ 	]HUGE_VAL[ 	]/a\
#endif
' $file_to_fix > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Solaris math.h and floatingpoint.h define __P without protection,
# which conflicts with the fixproto definition.  The fixproto
# definition and the Solaris definition are used the same way.
for file in math.h floatingpoint.h; do
  base=`basename $file`.$$
  if [ -r ${LIB}/$file ]; then
    file_to_fix=${LIB}/$file
  else
    if [ -r ${INPUT}/$file ]; then
      file_to_fix=${INPUT}/$file
    else
      file_to_fix=""
    fi
  fi
  if [ \! -z "$file_to_fix" ]; then
    echo Checking $file_to_fix
    sed -e '/^#define[ 	]*__P/i\
#ifndef __P
'\
        -e '/^#define[ 	]*__P/a\
#endif
' $file_to_fix > /tmp/$base
    if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
      true
    else
      echo Fixed $file_to_fix
      rm -f ${LIB}/$file
      cp /tmp/$base ${LIB}/$file
      chmod a+r ${LIB}/$file
    fi
   rm -f /tmp/$base
  fi
done

# The Solaris math.h defines struct exception, which conflicts with
# the class exception defined in the C++ file std/stdexcept.h.  We
# redefine it to __math_exception.  This is not a great fix, but I
# haven't been able to think of anything better.
file=math.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '/struct exception/i\
#ifdef __cplusplus\
#define exception __math_exception\
#endif'\
      -e '/struct exception/a\
#ifdef __cplusplus\
#undef exception\
#endif' $file_to_fix > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# Similarly for struct queue in sys/stream.h.
file=sys/stream.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '/struct[ 	]*queue/i\
#ifdef __cplusplus\
#define queue __stream_queue\
#endif'\
      -e '/struct[ 	]*queue/a\
#ifdef __cplusplus\
#undef queue\
#endif' $file_to_fix > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    mkdir -p $LIB/`dirname $file`
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

# If arpa/inet.h prototypes are incompatible with the ones we just
# installed in <sys/byteorder.h>, just remove the protos.
set -x
file=arpa/inet.h
base=`basename $file`.$$
if [ -r ${LIB}/$file ]; then
  file_to_fix=${LIB}/$file
else
  if [ -r ${INPUT}/$file ]; then
    file_to_fix=${INPUT}/$file
  else
    file_to_fix=""
  fi
fi
if [ \! -z "$file_to_fix" ]; then
  echo Checking $file_to_fix
  sed -e '/^extern.*htons.*(in_port_t)/d' \
      -e '/^extern.*ntohs.*(in_port_t)/d' \
  $file_to_fix > /tmp/$base
  if cmp $file_to_fix /tmp/$base >/dev/null 2>&1; then \
    true
  else
    echo Fixed $file_to_fix
    mkdir -p $LIB/`dirname $file`
    rm -f ${LIB}/$file
    cp /tmp/$base ${LIB}/$file
    chmod a+r ${LIB}/$file
  fi
  rm -f /tmp/$base
fi

echo 'Removing unneeded directories:'
cd $LIB
files=`find . -type d \! -name '.' -print | sort -r`
for file in $files; do
  rmdir $LIB/$file > /dev/null 2>&1
done

if $LINKS; then
  echo 'Making internal symbolic non-directory links'
  cd ${INPUT}
  files=`find . -type l -print`
  for file in $files; do
    dest=`ls -ld $file | sed -n 's/.*-> //p'`
    if expr "$dest" : '[^/].*' > /dev/null; then    
      target=${LIB}/`echo $file | sed "s|[^/]*\$|$dest|"`
      if [ -f $target ]; then
        ln -s $dest ${LIB}/$file >/dev/null 2>&1
      fi
    fi
  done
fi

cd ${ORIG_DIR}

echo 'Replacing <sys/byteorder.h>'
if [ \! -d $LIB/sys ]; then
  mkdir $LIB/sys
fi
rm -f ${LIB}/sys/byteorder.h
cat <<'__EOF__' >${LIB}/sys/byteorder.h
#ifndef _SYS_BYTEORDER_H
#define _SYS_BYTEORDER_H

/* Functions to convert `short' and `long' quantities from host byte order
   to (internet) network byte order (i.e. big-endian).

   Written by Ron Guilmette (rfg@ncd.com).

   This isn't actually used by GCC.  It is installed by fixinc.svr4.

   For big-endian machines these functions are essentially no-ops.

   For little-endian machines, we define the functions using specialized
   asm sequences in cases where doing so yields better code (e.g. i386).  */

#if !defined (__GNUC__) && !defined (__GNUG__)
#error You lose!  This file is only useful with GNU compilers.
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __BYTE_ORDER__
/* Byte order defines.  These are as defined on UnixWare 1.1, but with
   double underscores added at the front and back.  */
#define __LITTLE_ENDIAN__   1234
#define __BIG_ENDIAN__      4321
#define __PDP_ENDIAN__      3412
#endif

#ifdef __STDC__
static __inline__ unsigned long htonl (unsigned long);
static __inline__ unsigned short htons (unsigned int);
static __inline__ unsigned long ntohl (unsigned long);
static __inline__ unsigned short ntohs (unsigned int);
#endif /* defined (__STDC__) */

#if defined (__i386__)

#ifndef __BYTE_ORDER__
#define __BYTE_ORDER__ __LITTLE_ENDIAN__
#endif

/* Convert a host long to a network long.  */

/* We must use a new-style function definition, so that this will also
   be valid for C++.  */
static __inline__ unsigned long
htonl (unsigned long __arg)
{
  register unsigned long __result;

  __asm__ ("xchg%B0 %b0,%h0\n\
	ror%L0 $16,%0\n\
	xchg%B0 %b0,%h0" : "=q" (__result) : "0" (__arg));
  return __result;
}

/* Convert a host short to a network short.  */

static __inline__ unsigned short
htons (unsigned int __arg)
{
  register unsigned short __result;

  __asm__ ("xchg%B0 %b0,%h0" : "=q" (__result) : "0" (__arg));
  return __result;
}

#elif ((defined (__i860__) && !defined (__i860_big_endian__))	\
       || defined (__ns32k__) || defined (__vax__)		\
       || defined (__spur__) || defined (__arm__))

#ifndef __BYTE_ORDER__
#define __BYTE_ORDER__ __LITTLE_ENDIAN__
#endif

/* For other little-endian machines, using C code is just as efficient as
   using assembly code.  */

/* Convert a host long to a network long.  */

static __inline__ unsigned long
htonl (unsigned long __arg)
{
  register unsigned long __result;

  __result = (__arg >> 24) & 0x000000ff;
  __result |= (__arg >> 8) & 0x0000ff00;
  __result |= (__arg << 8) & 0x00ff0000;
  __result |= (__arg << 24) & 0xff000000;
  return __result;
}

/* Convert a host short to a network short.  */

static __inline__ unsigned short
htons (unsigned int __arg)
{
  register unsigned short __result;

  __result = (__arg << 8) & 0xff00;
  __result |= (__arg >> 8) & 0x00ff;
  return __result;
}

#else /* must be a big-endian machine */

#ifndef __BYTE_ORDER__
#define __BYTE_ORDER__ __BIG_ENDIAN__
#endif

/* Convert a host long to a network long.  */

static __inline__ unsigned long
htonl (unsigned long __arg)
{
  return __arg;
}

/* Convert a host short to a network short.  */

static __inline__ unsigned short
htons (unsigned int __arg)
{
  return __arg;
}

#endif /* big-endian */

/* Convert a network long to a host long.  */

static __inline__ unsigned long
ntohl (unsigned long __arg)
{
  return htonl (__arg);
}

/* Convert a network short to a host short.  */

static __inline__ unsigned short
ntohs (unsigned int __arg)
{
  return htons (__arg);
}

#ifdef __cplusplus
} /* extern "C" */
#endif

__EOF__

if [ -r ${INPUT}/sys/byteorder.h ]; then
  if grep BYTE_ORDER ${INPUT}/sys/byteorder.h >/dev/null 2>/dev/null; then
    cat <<'__EOF__' >>${LIB}/sys/byteorder.h
#ifndef BYTE_ORDER
#define LITTLE_ENDIAN __LITTLE_ENDIAN__
#define BIG_ENDIAN __BIG_ENDIAN__
#define PDP_ENDIAN __PDP_ENDIAN__
#define BYTE_ORDER __BYTE_ORDER__
#endif

__EOF__
  fi
fi

cat <<'__EOF__' >>${LIB}/sys/byteorder.h
#endif /* !defined (_SYS_BYTEORDER_H) */
__EOF__

chmod a+r ${LIB}/sys/byteorder.h

done

exit 0
