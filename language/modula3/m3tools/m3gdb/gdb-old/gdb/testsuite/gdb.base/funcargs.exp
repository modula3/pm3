# Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "funcargs"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}
if  { [compile "${srcdir}/${subdir}/${srcfile} -g -o ${binfile}"] != "" } {
    perror "Couldn't compile ${srcfile}"
    return -1
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
execute_anywhere "rm -f ${binfile}.ci"
if  { [compile "-E ${srcdir}/${subdir}/compiler.c > ${binfile}.ci"] != "" } {
    perror "Couldn't make ${binfile}.ci file"
    return -1
}
source ${binfile}.ci

#
# Locate actual args; integral types.
#

proc integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call0a\n" ; expect -re ".*$prompt $"
    send "break call0b\n" ; expect -re ".*$prompt $"
    send "break call0c\n" ; expect -re ".*$prompt $"
    send "break call0d\n" ; expect -re ".*$prompt $"
    send "break call0e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call0a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    expect {
	-re ".* call0a \\(c=97 'a', s=1, i=2, l=3\\) .*$prompt $" {
	    pass "run to call0a"
	}
	-re "$prompt $"  { fail "run to call0a" ; return }
	timeout { fail "(timeout) run to call0a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print c" ".* = 97 'a'" "print c after run to call0a" 
    gdb_test "print s" ".* = 1" "print s after run to call0a"
    gdb_test "print i" ".* = 2" "print i after run to call0a"
    gdb_test "print l " ".* = 3" "print l after run to call0a"

    # Continue; should stop at call0b and print actual arguments.
    if [gdb_test "cont" ".* call0b \\(s=1, i=2, l=3, c=97 'a'\\) .*" "continue to call0b"] {
	return 
    }

    # Continue; should stop at call0c and print actual arguments.
    if [gdb_test "cont" ".* call0c \\(i=2, l=3, c=97 'a', s=1\\) .*" "continue to call0c"] {
	return
    }

    # Continue; should stop at call0d and print actual arguments.
    if [gdb_test "cont" ".* call0d \\(l=3, c=97 'a', s=1, i=2\\) .*" "continue to call0d";] {
	return
    }

    # Continue; should stop at call0e and print actual arguments.
    if [gdb_test "cont" ".* call0e \\(c1=97 'a', l=3, c2=97 'a', i=2, c3=97 'a', s=1, c4=97 'a', c5=97 'a'\\) .*" "continue to call0e" ] {
	return
    }
}

#
# Locate actual args; unsigned integral types.
#

proc unsigned_integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call1a\n" ; expect -re ".*$prompt $"
    send "break call1b\n" ; expect -re ".*$prompt $"
    send "break call1c\n" ; expect -re ".*$prompt $"
    send "break call1d\n" ; expect -re ".*$prompt $"
    send "break call1e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call1a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    expect {
	-re ".* call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*$prompt $" {
	    pass "run to call1a"
	}
	-re "$prompt $" { fail "run to call1a" ; return }
	timeout { fail "(timeout) run to call1a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print uc" ".* = 98 'b'"
    gdb_test "print us" ".* = 6"
    gdb_test "print ui" ".* = 7"
    gdb_test "print ul" ".* = 8"
    
    # Continue; should stop at call1b and print actual arguments.
    if [gdb_test "cont" ".* call1b \\(us=6, ui=7, ul=8, uc=98 'b'\\) .*" "continue to call1b"] {
	return 
    }

    # Continue; should stop at call1c and print actual arguments.
    if [gdb_test "cont" ".* call1c \\(ui=7, ul=8, uc=98 'b', us=6\\) .*" "continue to call1c"] {
	return 
    }

    # Continue; should stop at call1d and print actual arguments.
    if [gdb_test "cont" ".* call1d \\(ul=8, uc=98 'b', us=6, ui=7\\) .*" "continue to call1d"] {
	return
    }

    # Continue; should stop at call1e and print actual arguments.
    if [gdb_test "cont" ".* call1e \\(uc1=98 'b', ul=8, uc2=98 'b', ui=7, uc3=98 'b', us=6, uc4=98 'b', uc5=98 'b'\\) .*" "continue to call1e"] {
	return
    }
}

#
# Locate actual args; integrals mixed with floating point.
#

proc float_and_integral_args {} {
    global prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call2a\n" ; expect -re ".*$prompt $"
    send "break call2b\n" ; expect -re ".*$prompt $"
    send "break call2c\n" ; expect -re ".*$prompt $"
    send "break call2d\n" ; expect -re ".*$prompt $"
    send "break call2e\n" ; expect -re ".*$prompt $"
    send "break call2f\n" ; expect -re ".*$prompt $"
    send "break call2g\n" ; expect -re ".*$prompt $"
    send "break call2h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call2a and print actual arguments.

    setup_xfail "i960-*-*" 1813
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    gdb_run_cmd
    expect {
	-re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$prompt $" { pass "run to call2a" }
	-re "$prompt $" { fail "run to call2a" ; return }
	timeout { fail "(timeout) run to call2a" ; return }
    }

    # Print each arg as a double check to see if we can print
    gdb_test "print c" ".* = 97 'a'" "print c after run to call2a"
    gdb_test "print f1" ".* = 4" "print f1 after run to call2a"
    gdb_test "print s" ".* = 1" "print s after run to call2a"
    gdb_test "print d1" ".* = 5" "print d1 after run to call2a"
    gdb_test "print i" ".* = 2" "print i after run to call2a"
    gdb_test "print f2" ".* = 4" "print f2 after run to call2a"
    gdb_test "print l" ".* = 3" "print l after run to call2a"
    gdb_test "print d2" ".* = 5" "print d2 after run to call2a"

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    # Continue; should stop at call2b and print actual arguments.
    if [gdb_test "cont" ".* call2b \\(f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a'\\) .*" "continue to call2b"] {
	return
    }

    # Continue; should stop at call2c and print actual arguments.
    if [gdb_test "cont" ".* call2c \\(s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4\\) .*" "continue to call2c"] {
	return
    }

    # Continue; should stop at call2d and print actual arguments.
    if [gdb_test "cont" ".* call2d \\(d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1\\) .*" "continue to call2d"] {
	return
    }

    # Continue; should stop at call2e and print actual arguments.
    if [gdb_test "cont" ".* call2e \\(i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5\\) .*" "continue to call2e"] {
	return
    }

    # Continue; should stop at call2f and print actual arguments.
    if [gdb_test "cont" ".* call2f \\(f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2\\) .*" "continue to call2f"] {
	return
    }

    # Continue; should stop at call2g and print actual arguments.
    if [gdb_test "cont" ".* call2g \\(l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4\\) .*" "continue to call2g"] {
	return
    }

    # Continue; should stop at call2h and print actual arguments.
    if [gdb_test "cont" ".* call2h \\(d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3\\) .*" "continue to call2h"] {
	return
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call2i\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call2i and print actual arguments.
    if [gdb_test "cont" ".* call2i \\(c1=97 'a', f1=4, c2=97 'a', c3=97 'a', d1=5, c4=97 'a', c5=97 'a', c6=97 'a', f2=4, s=1, c7=97 'a', d2=5\\) .*" "continue to call2i"] {
	return
    }
}

#
# Locate actual args; dereference pointers to ints and floats.
#

proc pointer_args {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call3a\n" ; expect -re ".*$prompt $"
    send "break call3b\n" ; expect -re ".*$prompt $"
    send "break call3c\n" ; expect -re ".*$prompt $"

    # Run; should stop at call3a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call3a \\(cp=$hex \"a\", sp=$hex, ip=$hex, lp=$hex\\) .*$prompt $" { pass "run to call3a" }
	-re "$prompt $" { fail "run to call3a" ; return }
	timeout { fail "(timeout) run to call3a" ; return }
    }

    gdb_test "print *cp" ".* = 97 'a'"
    gdb_test "print *sp" ".* = 1"
    gdb_test "print *ip" ".* = 2"
    gdb_test "print *lp" ".* = 3"

    # Continue; should stop at call3b and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3b \\(ucp=$hex \"b\", usp=$hex, uip=$hex, ulp=$hex\\) .*" "continue to call3b"] {
	return
    }

    gdb_test "print *ucp" ".* = 98 'b'"
    gdb_test "print *usp" ".* = 6"
    gdb_test "print *uip" ".* = 7"
    gdb_test "print *ulp" ".* = 8"

    # Continue; should stop at call3c and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3c \\(fp=$hex, dp=$hex\\) .*" "continue to call3c"] {
	return
    }

    gdb_test "print *fp" ".* = 4"
    gdb_test "print *dp" ".* = 5"

    pass "locate actual args, pointer types"
}

#
# Locate actual args; structures and unions passed by reference.
#

proc structs_by_reference {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call4a\n" ; expect -re ".*$prompt $"
    send "break call4b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call4a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call4a \\(stp=$hex\\) .*$prompt $" {
	    pass "run to call4a"
	}
	-re "$prompt $" { fail "run to call4a" ; return }
	timeout { fail "(timeout) run to call4a" ; return }
    }

    gdb_test "print *stp" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call4b and print actual arguments.
    # Try dereferencing the arguments.

    gdb_test "cont" ".* call4b \\(unp=$hex\\) .*" "continue to call4b"

    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}"

    pass "locate actual args, structs/unions passed by reference"
}

#
# Locate actual args; structures and unions passed by value.
#

proc structs_by_value {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call5a\n" ; expect -re ".*$prompt $"
    send "break call5b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call5a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".* call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*$prompt $" {
	    pass "run to call5a"
	}
	-re "$prompt $" { fail "run to call5a" ; return }
	timeout { fail "(timeout) run to call5a" ; return }
    }

    gdb_test "print st" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call5b and print actual arguments.
    # Try dereferencing the arguments.
    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
	"continue to call5b"

    # sizeof int != sizeof long on h8300
    setup_xfail "h8300*-*-*"
    gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}"
}

#
# Locate actual args; discard, shuffle, and call
#

proc discard_and_shuffle {} {
    global prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call6a\n" ; expect -re ".*$prompt $"
    send "break call6b\n" ; expect -re ".*$prompt $"
    send "break call6c\n" ; expect -re ".*$prompt $"
    send "break call6d\n" ; expect -re ".*$prompt $"
    send "break call6e\n" ; expect -re ".*$prompt $"
    send "break call6f\n" ; expect -re ".*$prompt $"
    send "break call6g\n" ; expect -re ".*$prompt $"
    send "break call6h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call6a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, call6a .*$prompt $" { pass "run to call6a" }
	-re "$prompt $" { fail "run to call6a" ; return }
	timeout { fail "(timeout) run to call6a" ; return }
    }

    setup_xfail "rs6000-*-*"
    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix5*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6a" }
	-re "$prompt $" { fail "backtrace from call6a" ; return }
	timeout { fail "(timeout) backtrace from call6a" ; return }
    }

    # Continue; should stop at call6b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6b .*$prompt $" { pass "continue to call6b" }
	-re "$prompt $" { fail "continue to call6b" ; return }
	timeout { fail "(timeout) continue to call6b" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n]+
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6b" }
	-re "$prompt $" { fail "backtrace from call6b" ; return }
	timeout { fail "(timeout) backtrace from call6b" ; return }
    }

    # Continue; should stop at call6c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6c .*$prompt $" { pass "continue to call6c" }
	-re "$prompt $" { fail "continue to call6c" ; return }
	timeout { fail "(timeout) continue to call6c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6c" }
	-re "$prompt $" { fail "backtrace from call6c" ; return }
	timeout { fail "(timeout) backtrace from call6c" ; return }
    }

    # Continue; should stop at call6d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6d .*$prompt $" { pass "continue to call6d" }
	-re "$prompt $" { fail "continue to call6d" ; return }
	timeout { fail "(timeout) continue to call6d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6d" }
	-re "$prompt $" { fail "backtrace from call6d" ; return }
	timeout { fail "(timeout) backtrace from call6d" ; return }
    }

    # Continue; should stop at call6e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6e .*$prompt $" { pass "continue to call6e" }
	-re "$prompt $" { fail "continue to call6e" ; return }
	timeout { fail "(timeout) continue to call6e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6e" }
	-re "$prompt $" { fail "backtrace from call6e" ; return }
	timeout { fail "(timeout) backtrace from call6e" ; return }
    }

    # Continue; should stop at call6f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6f .*$prompt $" { pass "continue to call6f" }
	-re "$prompt $" { fail "continue to call6f" ; return }
	timeout { fail "(timeout) continue to call6f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6f" }
	-re "$prompt $" { fail "backtrace from call6f" ; return }
	timeout { fail "(timeout) backtrace from call6f" ; return }
    }

    # Continue; should stop at call6g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6g .*$prompt $" { pass "continue to call6g" }
	-re "$prompt $" { fail "continue to call6g" ; return }
	timeout { fail "(timeout) continue to call6g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6g" }
	-re "$prompt $" { fail "backtrace from call6g" ; return }
	timeout { fail "(timeout) backtrace from call6g" ; return }
    }

    # Continue; should stop at call6h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6h .*$prompt $" { pass "continue to call6h" }
	-re "$prompt $" { fail "continue to call6h" ; return }
	timeout { fail "(timeout) continue to call6h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6h" }
	-re "$prompt $" { fail "backtrace from call6h" ; return }
	timeout { fail "(timeout) backtrace from call6h" ; return }
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call6i\n" ; expect -re ".*$prompt $"
    send "break call6j\n" ; expect -re ".*$prompt $"
    send "break call6k\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call6i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6i .*$prompt $" { pass "continue to call6i" }
	-re "$prompt $" { fail "continue to call6i" ; return }
	timeout { fail "(timeout) continue to call6i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6i" }
	-re "$prompt $" { fail "backtrace from call6i" ; return }
	timeout { fail "(timeout) backtrace from call6i" ; return }
    }

    # Continue; should stop at call6j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6j .*$prompt $" { pass "continue to call6j" }
	-re "$prompt $" { fail "continue to call6j" ; return }
	timeout { fail "(timeout) continue to call6j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6j" }
	-re "$prompt $" { fail "backtrace from call6j" ; return }
	timeout { fail "(timeout) backtrace from call6j" ; return }
    }

    # Continue; should stop at call6k and print actual arguments.
    # Print backtrace.
    # This fails on i960-*-vxworks because gdb gets confused by
    # breakpoints on adjacent instructions.
    setup_xfail "i960-*-vxworks" 1786
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6k .*$prompt $" {
	    pass "continue to call6k"
	}
	-re "$prompt $" { fail "continue to call6k"; return }
	timeout { fail "(timeout) continue to call6k"; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call6k \\(\\) .*\r
.* call6j \\(ul=8\\) .*\r
.* call6i \\(ui=7, ul=8\\) .*\r
.* call6h \\(us=6, ui=7, ul=8\\) .*\r
.* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call6k" }
	-re "$prompt $" { fail "backtrace from call6k" ; return }
	timeout { fail "(timeout) backtrace from call6k" ; return }
    }
}

#
# Locate actual args; shuffle round robin and call
#

proc shuffle_round_robin {} {
    global prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    send "break call7a\n" ; expect -re ".*$prompt $"
    send "break call7b\n" ; expect -re ".*$prompt $"
    send "break call7c\n" ; expect -re ".*$prompt $"
    send "break call7d\n" ; expect -re ".*$prompt $"
    send "break call7e\n" ; expect -re ".*$prompt $"
    send "break call7f\n" ; expect -re ".*$prompt $"
    send "break call7g\n" ; expect -re ".*$prompt $"
    send "break call7h\n" ; expect -re ".*$prompt $"

    # Run; should stop at call7a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, call7a .*$prompt $" {
	    pass "run to call7a"
	}
	-re "$prompt $" { fail "run to call7a" ; return }
	timeout { fail "(timeout) run to call7a" ; return }
    }

    setup_xfail "i960-*-*" 1813
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" "mips-sgi-irix5*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7a" }
	-re "$prompt $" { fail "backtrace from call7a" ; return }
	timeout { fail "(timeout) backtrace from call7a" ; return }
    }

    # Continue; should stop at call7b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7b .*$prompt $" { pass "continue to call7b" }
	-re "$prompt $" { fail "continue to call7b" ; return }
	timeout { fail "(timeout) continue to call7b" ; return }
    }

    if {$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7b" }
	-re "$prompt $" { fail "backtrace from call7b" ; return }
	timeout { fail "(timeout) backtrace from call7b" ; return }
    }

    # Continue; should stop at call7c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7c .*$prompt $" { pass "continue to call7c" }
	-re "$prompt $" { fail "continue to call7c" ; return }
	timeout { fail "(timeout) continue to call7c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7c" }
	-re "$prompt $" { fail "backtrace from call7c" ; return }
	timeout { fail "(timeout) backtrace from call7c" ; return }
    }

    # Continue; should stop at call7d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7d .*$prompt $" { pass "continue to call7d" }
	-re "$prompt $" { fail "continue to call7d" ; return }
	timeout { fail "(timeout) continue to call7d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7d" }
	-re "$prompt $" { fail "backtrace from call7d" ; return }
	timeout { fail "(timeout) backtrace from call7d" ; return }
    }

    # Continue; should stop at call7e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re "Breakpoint $decimal, call7e .*$prompt $" { pass "continue to call7e" }
	-re "$prompt $" { fail "continue to call7e" ; return }
	timeout { fail "(timeout) continue to call7e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7e" }
	-re "$prompt $" { fail "backtrace from call7e" ; return }
	timeout { fail "(timeout) backtrace from call7e" ; return }
    }

    # Continue; should stop at call7f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7f .*$prompt $" { pass "continue to call7f" }
	-re "$prompt $" { fail "continue to call7f" ; return }
	timeout { fail "(timeout) continue to call7f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7f" }
	-re "$prompt $" { fail "backtrace from call7f" ; return }
	timeout { fail "(timeout) backtrace from call7f" ; return }
    }

    # Continue; should stop at call7g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7g .*$prompt $" { pass "continue to call7g" }
	-re "$prompt $" { fail "continue to call7g" ; return }
	timeout { fail "(timeout) continue to call7g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7g" }
	-re "$prompt $" { fail "backtrace from call7g" ; return }
	timeout { fail "(timeout) backtrace from call7g" ; return }
    }

    # Continue; should stop at call7h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7h .*$prompt $" { pass "continue to call7h" }
	-re "$prompt $" { fail "continue to call7h" ; return }
	timeout { fail "(timeout) continue to call7h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7h" }
	-re "$prompt $" { fail "backtrace from call7h" ; return }
	timeout { fail "(timeout) backtrace from call7h" ; return }
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    send "break call7i\n" ; expect -re ".*$prompt $"
    send "break call7j\n" ; expect -re ".*$prompt $"
    send "break call7k\n" ; expect -re ".*$prompt $"

    # Continue; should stop at call7i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7i .*$prompt $" { pass "continue to call7i" }
	-re "$prompt $" { fail "continue to call7i" ; return }
	timeout { fail "(timeout) continue to call7i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7i" }
	-re "$prompt $" { fail "backtrace from call7i" ; return }
	timeout { fail "(timeout) backtrace from call7i" ; return }
    }

    # Continue; should stop at call7j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7j .*$prompt $" { pass "continue to call7j" }
	-re "$prompt $" { fail "continue to call7j" ; return }
	timeout { fail "(timeout) continue to call7j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7j" }
	-re "$prompt $" { fail "backtrace from call7j" ; return }
	timeout { fail "(timeout) backtrace from call7j" ; return }
    }

    # Continue; should stop at call7k and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7k .*$prompt $" { pass "continue to call7k" }
	-re "$prompt $" { fail "continue to call7k" ; return }
	timeout { fail "(timeout) continue to call7k" ; return }
    }

    if {!$gcc_compiled} then { setup_xfail "mips-sgi-irix*" }
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) .*\r
.* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) .*\r
.* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) .*\r
.* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) .*\r
.* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) .*\r
.* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) .*\r
.* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) .*\r
.* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) .*\r
.* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) .*\r
.* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "backtrace from call7k" }
	-re "$prompt $" { fail "backtrace from call7k" ; return }
	timeout { fail "(timeout) backtrace from call7k" ; return }
    }
}

#
# Locate actual args; recursive passing of structs by value
#

proc recursive_structs_by_value {} {
    global prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    send "break hitbottom\n" ; expect -re ".*$prompt $"

    # Run; should stop at hitbottom and print actual arguments.
    # Print backtrace.
    gdb_run_cmd
    expect {
	-re ".*Breakpoint $decimal, hitbottom .*$prompt $" { pass "run to hitbottom" }
	-re "$prompt $" { fail "run to hitbottom" ; return }
	timeout { fail "(timeout) run to hitbottom" ; return }
    }

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\[\r\n\]+
.* hitbottom \\(\\) .*\r
.* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) .*\r
.* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) .*\r
.* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) .*\r
.* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) .*\r
.* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) .*\r
.* test_struct_args \\(\\) .*\r
.* main \\(.*\\) .*\r
$prompt $" { pass "recursive passing of structs by value" }
	-re "$prompt $" { fail "recursive passing of structs by value" ; return }
	timeout { fail "(timeout) recursive passing of structs by value" ; return }
    }
}

proc funcargs_reload { } {
    global objdir
    global subdir
    global binfile
    global srcdir

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load ${binfile}
    }
}

#
# Test for accessing local stack variables in functions which call alloca
#
proc localvars_after_alloca { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto localvars_after_alloca ] } then { return 0 }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c after runto localvars_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s after runto localvars_after_alloca"
    gdb_test "print i" " = 2" "print i after runto localvars_after_alloca"
    gdb_test "print l" " = 3" "print l after runto localvars_after_alloca"

    send "next\n"
    expect {
	-re ".*$prompt $" { pass "next in localvars_after_alloca()" }
	timeout { fail "next in localvars_after_alloca()" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'" "print c in localvars_after_alloca"
    gdb_test "print s" " = 1" "print s in localvars_after_alloca"
    gdb_test "print i" " = 2" "print i in localvars_after_alloca"
    gdb_test "print l" " = 3" "print l in localvars_after_alloca"

    gdb_test "backtrace 8" "#0.*localvars_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" "backtrace after alloca"
}

proc call_after_alloca { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto call_after_alloca_subr ] } then { return 0 }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in call_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in call_after_alloca"
    gdb_test "print i" " = 2" "print i in call_after_alloca"
    gdb_test "print l" " = 3" "print l in call_after_alloca"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" "#0.*call_after_alloca_subr \\(c=97 'a', s=1, i=2, l=3, uc=98 'b', us=11, ui=12, ul=13\\).*#1.*call_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#2.*main.*" "backtrace from call_after_alloca_subr"
}

#
# Test for accessing local stack variables, backtraces, finish,
# and finally stepping into indirect calls.  The point is that on the PA
# these use a funky `dyncall' mechanism which GDB needs to know about.
#
proc localvars_in_indirect_call { } {
    global prompt
    global hex
    global decimal
    global gcc_compiled

    # Can not use "runto call0a" as call0a is called several times
    # during single run.  Instead stop in a marker function and
    # take control from there.
    if { ! [ runto marker_indirect_call ] } then { return 0 }

    # break on the next call to call0a, then delete all the breakpoints
    # and start testing.
    gdb_test "break call0a" "Breakpoint .*" \
	"break call0a in localvars_in_indirect_call"
    gdb_test "continue" "call0a .*" "continue in localvars_in_indirect_call"
    delete_breakpoints
    
    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in localvars_in_indirect_call"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in localvars_in_indirect_call"
    gdb_test "print i" " = 2" "print i in localvars_in_indirect_call"
    gdb_test "print l" " = 3" "print l in localvars_in_indirect_call"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" \
	"#0.*call0a \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" \
	"backtrace in indirectly called function"

    # 
    # "finish" brings us back to main.  We then will try to step through
    # the second indirect call.  
    # On some targets (e.g. m68k) gdb will stop from the finish in midline
    # of the first indirect call. This is due to stack adjustment instructions
    # after the indirect call. In these cases we will step till we hit the
    # second indirect call.
    #

    send "finish\n"
    expect {
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$prompt $" {
	    pass "finish from indirectly called function"
	}
	-re ".*$prompt $" {
	    fail "finish from indirectly called function"
	    return
	}
	default { fail "finish from indirectly called function" ; return }
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "step" "call0a \\(c=97 'a', s=1, i=2, l=3\\).*" \
	"stepping into indirectly called function"
}

# Start with a fresh gdb.
#
# Test for stepping into indirect calls which may have trampolines (possibly
# cascaded) on both the call path and the return path.
# to handle trampolines.
#
proc test_stepping_over_trampolines { } {
    global prompt
    global hex
    global decimal

    # Stop in a marker function and take control from there.
    if { ! [ runto marker_call_with_trampolines ] } then { return 0 }

    # Cater for gdb stopping in midline, see comment for finish above.
    send "finish\n"
    expect {
	-re "marker_call_with_trampolines ..;.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "pointer_to_call_with_trampolines.*$prompt $" {
	    pass "finish from marker_call_with_trampolines"
	}
	-re ".*$prompt $" {
	    fail "finish from marker_call_with_trampolines"
	}
	default { fail "finish from marker_call_with_trampolines" ; return 0 }
    }

    # Try to step into the target function.
    gdb_test "step" "call_with_trampolines \\(d1=5\\).*" \
	"stepping into function called with trampolines"

    # Make we can backtrace and the argument looks correct.  */
    gdb_test "backtrace 8" "#0.*call_with_trampolines \\(d1=5\\).*1.*main.*" \
	"backtrace through call with trampolines"

    # Make sure we can get back to main.
    # Stepping back to main might stop again after the return statement
    # or immediately transfer control back to main if optimizations
    # are performed.
    send "step\n"
    expect {
	-re "main .* at.*$prompt $" {
	    pass "stepping back to main from function called with trampolines" ;
	    return 1
	}
	-re "\}.*End of call_with_trampolines.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re ".*$prompt $" {
	    fail "stepping back to main from function called with trampolines"
	}
	default { fail "stepping back to main from function called with trampolines" ; return 0 }
    }
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

integral_args
funcargs_reload
unsigned_integral_args
funcargs_reload
float_and_integral_args
funcargs_reload
pointer_args
funcargs_reload
structs_by_reference
funcargs_reload
structs_by_value
funcargs_reload
discard_and_shuffle
funcargs_reload
shuffle_round_robin
funcargs_reload
recursive_structs_by_value
funcargs_reload
localvars_after_alloca
funcargs_reload
call_after_alloca
funcargs_reload
localvars_in_indirect_call
funcargs_reload
test_stepping_over_trampolines
