//    <insn> ::=
//        <insn-word> { "+" <insn-word> }
//        ":" <format-name>
//        ":" <filter-flags>
//        ":" <options>
//        ":" <name>
//        <nl>
//        { <insn-model> }
//        { <insn-mnemonic> }
//        <code-block>
//


// IGEN config - mips16
:option:16::insn-bit-size:16
:option:16::hi-bit-nr:15
:option:16::insn-specifying-widths:true
:option:16::gen-delayed-branch:false

// IGEN config - mips32/64..
:option:32::insn-bit-size:32
:option:32::hi-bit-nr:31
:option:32::insn-specifying-widths:true
:option:32::gen-delayed-branch:false


// Generate separate simulators for each target
// :option:::multi-sim:true


// Models known by this simulator
:model:::mipsI:mipsI:
:model:::mipsII:mipsII:
:model:::mipsIII:mipsIII:
:model:::mipsIV:mipsIV:
:model:::mips16:mips16:
:model:::r3900:mips3900:
:model:::vr5000:mips5000:



// Pseudo instructions known by IGEN
:internal::::illegal:
{
  SignalException (ReservedInstruction, 0);
}


// Pseudo instructions known by interp.c
// For grep - RSVD_INSTRUCTION, RSVD_INSTRUCTION_MASK
000000,5.*,5.*,5.*,5.OP,000101:SPECIAL:32::RSVD
"rsvd <OP>"
{
  SignalException (ReservedInstruction, instruction_0);
}



//
// Mips Architecture:
//
//        CPU Instruction Set (mipsI - mipsIV)
//


000000,5.RS,5.RT,5.RD,00000,100000:SPECIAL:32::ADD
"add r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  ALU32_BEGIN (GPR[RS]);
  ALU32_ADD (GPR[RT]);
  ALU32_END (GPR[RD]);
}


001000,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ADDI
"addi r<RT>, r<RS>, IMMEDIATE"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  ALU32_BEGIN (GPR[RS]);
  ALU32_ADD (EXTEND16 (IMMEDIATE));
  ALU32_END (GPR[RT]);
}


001001,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ADDIU
"add r<RT>, r<RS>, <IMMEDIATE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  signed32 temp = GPR[RS] + EXTEND16 (IMMEDIATE);
  GPR[RT] = EXTEND32 (temp);
}


000000,5.RS,5.RT,5.RD,00000,100001:SPECIAL:32::ADDU
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  signed32 temp = GPR[RS] + GPR[RT];
  GPR[RD] = EXTEND32 (temp);
}


000000,5.RS,5.RT,5.RD,00000,100100:SPECIAL:32::AND
"and r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = GPR[RS] & GPR[RT];
}


001100,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ANDI
"and r<RT>, r<RS>, <IMMEDIATE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RT] = GPR[RS] & IMMEDIATE;
}


000100,5.RS,5.RT,16.OFFSET:NORMAL:32::BEQ
"beq r<RS>, r<RT>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
    DELAY_SLOT (NIA + offset);
}


010100,5.RS,5.RT,16.OFFSET:NORMAL:32::BEQL
"beql r<RS>, r<RT>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000001,5.RS,00001,16.OFFSET:REGIMM:32::BGEZ
"bgez r<RS>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] >= 0)
    DELAY_SLOT (NIA + offset);
}


000001,5.RS!31,10001,16.OFFSET:REGIMM:32::BGEZAL
"bgezal r<RS>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  RA = (CIA + 8);
  if ((signed_word) GPR[RS] >= 0)
    DELAY_SLOT (NIA + offset);
}


000001,5.RS!31,10011,16.OFFSET:REGIMM:32::BGEZALL
"bgezall r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  RA = (CIA + 8);
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] >= 0)
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000001,5.RS,00011,16.OFFSET:REGIMM:32::BGEZL
"bgezl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] >= 0)
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000111,5.RS,00000,16.OFFSET:NORMAL:32::BGTZ
"bgtz r<RS>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] > 0)
    DELAY_SLOT (NIA + offset);
}


010111,5.RS,00000,16.OFFSET:NORMAL:32::BGTZL
"bgtzl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] > 0)
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000110,5.RS,00000,16.OFFSET:NORMAL:32::BLEZ
"blez r<RS>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] <= 0)
    DELAY_SLOT (NIA + offset);
}


010110,5.RS,00000,16.OFFSET:NORMAL:32::BLEZL
"bgezl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] <= 0)
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000001,5.RS,00000,16.OFFSET:REGIMM:32::BLTZ
"bltz r<RS>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] < 0)
    DELAY_SLOT (NIA + offset);
}


000001,5.RS!31,10000,16.OFFSET:REGIMM:32::BLTZAL
"bltzal r<RS>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  RA = (CIA + 8);
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] < 0)
    DELAY_SLOT (NIA + offset);
}


000001,5.RS!31,10010,16.OFFSET:REGIMM:32::BLTZALL
"bltzall r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  RA = (CIA + 8);
  if ((signed_word) GPR[RS] < 0)
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000001,5.RS,00010,16.OFFSET:REGIMM:32::BLTZL
"bltzl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] < 0)
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000101,5.RS,5.RT,16.OFFSET:NORMAL:32::BNE
"bne r<RS>, r<RT>, <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
    DELAY_SLOT (NIA + offset);
}


010101,5.RS,5.RT,16.OFFSET:NORMAL:32::BNEL
"bnel r<RS>, r<RT>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
    DELAY_SLOT (NIA + offset);
  else
    NULLIFY_NEXT_INSTRUCTION ();
}


000000,20.CODE,001101:SPECIAL:32::BREAK
"break"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  SignalException(BreakPoint, instruction_0);
}


0100,ZZ!0!1!3,26.COP_FUN:NORMAL:32::COPz
"cop<ZZ> <COP_FUN>"
*mipsI,mipsII,mipsIII,mipsIV:
*r3900:
{
  DecodeCoproc (instruction_0);
}


000000,5.RS,5.RT,5.RD,00000,101100:SPECIAL:64::DADD
"dadd r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  ALU64_BEGIN (GPR[RS]);
  ALU64_ADD (GPR[RT]);
  ALU64_END (GPR[RT]);
}


011000,5.RS,5.RT,16.IMMEDIATE:NORMAL:64::DADDI
"daddi r<RT>, r<RS>, <IMMEDIATE>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  ALU64_BEGIN (GPR[RS]);
  ALU64_ADD (EXTEND16 (IMMEDIATE));
  ALU64_END (GPR[RT]);
}


011001,5.RS,5.RT,16.IMMEDIATE:NORMAL:64::DADDIU
"daddu r<RT>, r<RS>, <IMMEDIATE>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  GPR[RT] = GPR[RS] + EXTEND16 (IMMEDIATE);
}


000000,5.RS,5.RT,5.RD,00000,101101:SPECIAL:64::DADDU
"daddu r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = GPR[RS] + GPR[RT];
}


000000,5.RS,5.RT,0000000000011110:SPECIAL:64::DDIV
"ddiv r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  CHECKHILO ("Division");
  {
    signed64 n = GPR[RS];
    signed64 d = GPR[RT];
    if (d == 0)
      {
	LO = SIGNED64 (0x8000000000000000);
	HI = 0;
      }
    else if (d == -1 && n == SIGNED64 (0x8000000000000000))
      {
	LO = SIGNED64 (0x8000000000000000);
	HI = 0;
      }
    else
      {
	LO = (n / d);
	HI = (n % d);
      }
  }
}



000000,5.RS,5.RT,0000000000,011111:SPECIAL:64::DDIVU
"ddivu r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*r3900:
*vr5000:
{
  CHECKHILO ("Division");
  {
    unsigned64 n = GPR[RS];
    unsigned64 d = GPR[RT];
    if (d == 0)
      {
	LO = SIGNED64 (0x8000000000000000);
	HI = 0;
      }
    else
      {
	LO = (n / d);
	HI = (n % d);
      }
  }
}


000000,5.RS,5.RT,0000000000011010:SPECIAL:32::DIV
"div r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  CHECKHILO("Division");
  {
    signed32 n = GPR[RS];
    signed32 d = GPR[RT];
    if (d == 0)
      {
	LO = EXTEND32 (0x80000000);
	HI = EXTEND32 (0);
      }
    else if (d == -1 && d == 0x80000000)
      {
	LO = EXTEND32 (0x80000000);
	HI = EXTEND32 (0);
      }
    else
      {
	LO = EXTEND32 (n / d);
	HI = EXTEND32 (n % d);
      }
  }
}


000000,5.RS,5.RT,0000000000011011:SPECIAL:32::DIVU
"divu r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  CHECKHILO ("Division");
  {
    unsigned32 n = GPR[RS];
    unsigned32 d = GPR[RT];
    if (d == 0)
      {
	LO = EXTEND32 (0x80000000);
	HI = EXTEND32 (0);
      }
   else
     {
       LO = EXTEND32 (n / d);
       HI = EXTEND32 (n % d);
     }
  }
}


:function:::void:do_dmult:int rs, int rt, int rd, int signed_p
{
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];
  CHECKHILO ("Multiplication");
  /* make signed multiply unsigned */ 
  sign = 0;
  if (signed_p)
    {
      if (op1 < 0)
	{
	  op1 = - op1;
	  ++sign;
	}
      if (op2 < 0)
	{
	  op2 = - op2;
	  ++sign;
	}
    }
  /* multuply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
	 + (unsigned64) VL4_8 (m10)
	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
	+ (unsigned64) VH4_8 (mid)
	+ (unsigned64) VH4_8 (m01)
	+ (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
    {
      lo = -lo;
      if (lo == 0)
	hi = -hi;
      else
	hi = -hi - 1;
    }
  /* save the result HI/LO (and a gpr) */
  LO = lo;
  HI = hi;
  if (rd != 0)
    GPR[rd] = lo;
}


000000,5.RS,5.RT,0000000000011100:SPECIAL:64::DMULT
"dmult r<RS>, r<RT>"
*mipsIII,mipsIV:
*r3900:
{
  do_dmult (SD_, RS, RT, 0, 1);
}

000000,5.RS,5.RT,5.RD,00000011100:SPECIAL:64::DMULT
"dmult r<RS>, r<RT>":RD == 0
"dmult r<RD>, r<RS>, r<RT>"
*vr5000:
{
  do_dmult (SD_, RS, RT, RD, 1);
}



000000,5.RS,5.RT,0000000000011101:SPECIAL:64::DMULTU
"dmultu r<RS>, r<RT>"
*mipsIII,mipsIV:
*r3900:
{
  do_dmult (SD_, RS, RT, 0, 0);
}

000000,5.RS,5.RT,5.RD,00000011101:SPECIAL:64::DMULTU
"dmultu r<RD>, r<RS>, r<RT>":RD == 0
"dmultu r<RS>, r<RT>"
*vr5000:
{
  do_dmult (SD_, RS, RT, RD, 0);
}



00000000000,5.RT,5.RD,5.SHIFT,111000:SPECIAL:64::DSLL
"dsll r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = SHIFT;
  GPR[RD] = GPR[RT] << s;
}


00000000000,5.RT,5.RD,5.SHIFT,111100:SPECIAL:64::DSLL32
"dsll32 r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = 32 + SHIFT;
  GPR[RD] = GPR[RT] << s;
}


000000,5.RS,5.RT,5.RD,00000010100:SPECIAL:64::DSLLV
"dsllv r<RD>, r<RT>, r<RS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = MASKED64 (GPR[RS], 5, 0);
  GPR[RD] = GPR[RT] << s;
}


00000000000,5.RT,5.RD,5.SHIFT,111011:SPECIAL:64::DSRA
"dsra r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = SHIFT;
  GPR[RD] = ((signed64) GPR[RT]) >> s;
}


00000000000,5.RT,5.RD,5.SHIFT,111111:SPECIAL:64::DSRA32
"dsra32 r<RT>, r<RD>, <SHIFT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = 32 + SHIFT;
  GPR[RD] = ((signed64) GPR[RT]) >> s;
}


000000,5.RS,5.RT,5.RD,00000010111:SPECIAL:64::DSRAV
"dsra32 r<RT>, r<RD>, r<RS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = MASKED64 (GPR[RS], 5, 0);
  GPR[RD] = ((signed64) GPR[RT]) >> s;
}


00000000000,5.RT,5.RD,5.SHIFT,111010:SPECIAL:64::DSRL
"dsrav r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = SHIFT;
  GPR[RD] = (unsigned64) GPR[RT] >> s;
}


00000000000,5.RT,5.RD,5.SHIFT,111110:SPECIAL:64::DSRL32
"dsrl32 r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = 32 + SHIFT;
  GPR[RD] = (unsigned64) GPR[RT] >> s;
}


000000,5.RS,5.RT,5.RD,00000010110:SPECIAL:64::DSRLV
"dsrl32 r<RD>, r<RT>, r<RS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  int s = MASKED64 (GPR[RS], 5, 0);
  GPR[RD] = (unsigned64) GPR[RT] >> s;
}


000000,5.RS,5.RT,5.RD,00000101110:SPECIAL:64::DSUB
"dsub r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  ALU64_BEGIN (GPR[RS]);
  ALU64_SUB (GPR[RT]);
  ALU64_END (GPR[RD]);
}


000000,5.RS,5.RT,5.RD,00000101111:SPECIAL:64::DSUBU
"dsubu r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = GPR[RS] - GPR[RT];
}


000010,26.INSTR_INDEX:NORMAL:32::J
"j <INSTR_INDEX>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  /* NOTE: The region used is that of the delay slot NIA and NOT the
     current instruction */
  address_word region = (NIA & MASK (63, 28));
  DELAY_SLOT (region | (INSTR_INDEX << 2));
}


000011,26.INSTR_INDEX:NORMAL:32::JAL
"jal <INSTR_INDEX>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  /* NOTE: The region used is that of the delay slot and NOT the
     current instruction */
  address_word region = (NIA & MASK (63, 28));
  GPR[31] = CIA + 8;
  DELAY_SLOT (region | (INSTR_INDEX << 2));
}


000000,5.RS,00000,5.RD,00000001001:SPECIAL:32::JALR
"jalr r<RS>":RD == 31
"jalr r<RD>, r<RS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  address_word temp = GPR[RS];
  GPR[RD] = CIA + 8;
  DELAY_SLOT (temp);
}


000000,5.RS,000000000000000001000:SPECIAL:32::JR
"jr r<RS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  DELAY_SLOT (GPR[RS]);
}


100000,5.BASE,5.RT,16.OFFSET:NORMAL:32::LB
"lb r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((uword64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	{
	  uword64 memval = 0;
	  uword64 memval1 = 0;
	  uword64 mask = 0x7;
	  unsigned int shift = 0;
	  unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	  unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	  unsigned int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	  LoadMemory(&memval,&memval1,uncached,AccessLength_BYTE,paddr,vaddr,isDATA,isREAL);
	  byte = ((vaddr & mask) ^ (bigend << shift));
	  GPR[destreg] = (SIGNEXTEND(((memval >> (8 * byte)) & 0x000000FF),8));
	}
    }
  }
}


100100,5.BASE,5.RT,16.OFFSET:NORMAL:32::LBU
"lbu r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 0x7;
	  unsigned int shift = 0;
	  unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	  unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	  unsigned int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	  LoadMemory(&memval,&memval1,uncached,AccessLength_BYTE,paddr,vaddr,isDATA,isREAL);
	  byte = ((vaddr & mask) ^ (bigend << shift));
	  GPR[destreg] = (((memval >> (8 * byte)) & 0x000000FF));
	}
    }
  }
}


110111,5.BASE,5.RT,16.OFFSET:NORMAL:64::LD
"ld r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    LoadMemory(&memval,&memval1,uncached,AccessLength_DOUBLEWORD,paddr,vaddr,isDATA,isREAL);
	    GPR[destreg] = memval;
	  }
      }
  }
}


1101,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:64::LDCz
"ldc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    LoadMemory(&memval,&memval1,uncached,AccessLength_DOUBLEWORD,paddr,vaddr,isDATA,isREAL);
	    COP_LD(((instruction >> 26) & 0x3),destreg,memval);;
	  }
      }
  }
}


011010,5.BASE,5.RT,16.OFFSET:NORMAL:64::LDL
"ldl r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 7;
	  unsigned int reverse = (ReverseEndian ? mask : 0);
	  unsigned int bigend = (BigEndianCPU ? mask : 0);
	  int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
	  byte = ((vaddr & mask) ^ bigend);
	  if (!BigEndianMem)
	    paddr &= ~mask;
	  LoadMemory(&memval,&memval1,uncached,byte,paddr,vaddr,isDATA,isREAL);
	  GPR[destreg] = ((memval << ((7 - byte) * 8)) | (GPR[destreg] & (((unsigned64)1 << ((7 - byte) * 8)) - 1)));
	}
    }
  }
}


011011,5.BASE,5.RT,16.OFFSET:NORMAL:64::LDR
"ldr r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 7;
	  unsigned int reverse = (ReverseEndian ? mask : 0);
	  unsigned int bigend = (BigEndianCPU ? mask : 0);
	  int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
	  byte = ((vaddr & mask) ^ bigend);
	  if (BigEndianMem)
	    paddr &= ~mask;
	  LoadMemory(&memval,&memval1,uncached,(7 - byte),paddr,vaddr,isDATA,isREAL);
	  {
	    unsigned64 srcmask;
	    if (byte == 0)
	      srcmask = 0;
	    else
	      srcmask = ((unsigned64)-1 << (8 * (8 - byte)));
	    GPR[destreg] = ((GPR[destreg] & srcmask) | (memval >> (8 * byte)));
	  }
	}
    }
  }
}


100001,5.BASE,5.RT,16.OFFSET:NORMAL:32::LH
"lh r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 1) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int shift = 1;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_HALFWORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    GPR[destreg] = (SIGNEXTEND(((memval >> (8 * byte)) & 0x0000FFFF),16));
	  }
      }
  }
}


100101,5.BASE,5.RT,16.OFFSET:NORMAL:32::LHU
"lhu r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 1) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int shift = 1;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_HALFWORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    GPR[destreg] = (((memval >> (8 * byte)) & 0x0000FFFF));
	  }
      }
  }
}


110000,5.BASE,5.RT,16.OFFSET:NORMAL:32::LL
"ll r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int shift = 2;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    GPR[destreg] = (SIGNEXTEND(((memval >> (8 * byte)) & 0xFFFFFFFF),32));
	    LLBIT = 1;
	  }
      }
  }
}


110100,5.BASE,5.RT,16.OFFSET:NORMAL:64::LLD
"lld r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    LoadMemory(&memval,&memval1,uncached,AccessLength_DOUBLEWORD,paddr,vaddr,isDATA,isREAL);
	    GPR[destreg] = memval;
	    LLBIT = 1;
	  }
      }
  }
}


001111,00000,5.RT,16.IMMEDIATE:NORMAL:32::LUI
"lui r<RT>, <IMMEDIATE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RT] = EXTEND32 (IMMEDIATE << 16);
}


100011,5.BASE,5.RT,16.OFFSET:NORMAL:32::LW
"lw r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int shift = 2;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    GPR[destreg] = (SIGNEXTEND(((memval >> (8 * byte)) & 0xFFFFFFFF),32));
	  }
      }
  }
}


1100,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWCz
"lwc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int shift = 2;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    COP_LW(((instruction >> 26) & 0x3),destreg,(unsigned int)((memval >> (8 * byte)) & 0xFFFFFFFF));
	  }
      }
  }
}


100010,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWL
"lwl r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 3;
	  unsigned int reverse = (ReverseEndian ? mask : 0);
	  unsigned int bigend = (BigEndianCPU ? mask : 0);
	  int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
	  byte = ((vaddr & mask) ^ bigend);
	  if (!BigEndianMem)
	    paddr &= ~mask;
	  LoadMemory(&memval,&memval1,uncached,byte,paddr,vaddr,isDATA,isREAL);
	  if ((vaddr & (1 << 2)) ^ (BigEndianCPU << 2)) {
	    memval >>= 32;
	  }
	  GPR[destreg] = ((memval << ((3 - byte) * 8)) | (GPR[destreg] & (((unsigned64)1 << ((3 - byte) * 8)) - 1)));
	  GPR[destreg] = SIGNEXTEND(GPR[destreg],32);
	}
    }
  }
}


100110,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWR
"lwr r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 3;
	  unsigned int reverse = (ReverseEndian ? mask : 0);
	  unsigned int bigend = (BigEndianCPU ? mask : 0);
	  int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
	  byte = ((vaddr & mask) ^ bigend);
	  if (BigEndianMem)
	    paddr &= ~mask;
	  LoadMemory(&memval,&memval1,uncached,(3 - byte),paddr,vaddr,isDATA,isREAL);
	  if ((vaddr & (1 << 2)) ^ (BigEndianCPU << 2)) {
	    memval >>= 32;
	  }
	  {
	    unsigned64 srcmask;
	    if (byte == 0)
	      srcmask = 0;
	    else
	      srcmask = ((unsigned64)-1 << (8 * (4 - byte)));
	    GPR[destreg] = ((GPR[destreg] & srcmask) | (memval >> (8 * byte)));
	  }
	  GPR[destreg] = SIGNEXTEND(GPR[destreg],32);
	}
    }
  }
}


100111,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWU
"lwu r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int shift = 2;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    GPR[destreg] = (((memval >> (8 * byte)) & 0xFFFFFFFF));
	  }
      }
  }
}


000000,0000000000,5.RD,00000,010000:SPECIAL:32::MFHI
"mfhi r<RD>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = HI;
#if 0
  HIACCESS = 3;
#endif
}


000000,0000000000,5.RD,00000,010010:SPECIAL:32::MFLO
"mflo r<RD>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = LO;
#if 0
  LOACCESS = 3; /* 3rd instruction will be safe */
#endif
}


000000,5.RS,5.RT,5.RD,00000001011:SPECIAL:32::MOVN
"movn r<RD>, r<RS>, r<RT>"
*mipsIV:
*vr5000:
{
  if (GPR[RT] != 0)
    GPR[RD] = GPR[RS];
}


000000,5.RS,5.RT,5.RD,00000001010:SPECIAL:32::MOVZ
"movz r<RD>, r<RS>, r<RT>"
*mipsIV:
*vr5000:
{
  if (GPR[RT] == 0)
    GPR[RD] = GPR[RS];
}


000000,5.RS,000000000000000,010001:SPECIAL:32::MTHI
"mthi r<RS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
#if 0
  if (HIACCESS != 0)
    sim_io_eprintf (sd, "MT (move-to) over-writing HI register value\n");
#endif
  HI = GPR[RS];
#if 0
  HIACCESS = 3; /* 3rd instruction will be safe */
#endif
}


000000,5.RS,000000000000000010011:SPECIAL:32::MTLO
"mtlo r<RS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
#if 0
  if (LOACCESS != 0)
    sim_io_eprintf (sd, "MT (move-to) over-writing LO register value\n");
#endif
  LO = GPR[RS];
#if 0
  LOACCESS = 3; /* 3rd instruction will be safe */
#endif
}


000000,5.RS,5.RT,00000,00000011000:SPECIAL:32::MULT
"mult r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
{
  signed64 prod;
  CHECKHILO ("Multiplication");
  prod = (((signed64)(signed32) GPR[RS])
	  * ((signed64)(signed32) GPR[RT]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
}
000000,5.RS,5.RT,5.RD,00000011000:SPECIAL:32::MULT
"mult r<RD>, r<RS>, r<RT>"
*vr5000:
*r3900:
{
  signed64 prod;
  CHECKHILO ("Multiplication");
  prod = (((signed64)(signed32) GPR[RS])
	  * ((signed64)(signed32) GPR[RT]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (RD != 0)
    GPR[RD] = LO;
}


000000,5.RS,5.RT,00000,00000011001:SPECIAL:32::MULTU
"multu r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
{
  unsigned64 prod;
  CHECKHILO ("Multiplication");
  prod = (((unsigned64)(unsigned32) GPR[RS])
	  * ((unsigned64)(unsigned32) GPR[RT]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
}
000000,5.RS,5.RT,5.RD,00000011001:SPECIAL:32::MULTU
"multu r<RD>, r<RS>, r<RT>"
*vr5000:
*r3900:
{
  unsigned64 prod;
  CHECKHILO ("Multiplication");
  prod = (((unsigned64)(unsigned32) GPR[RS])
	  * ((unsigned64)(unsigned32) GPR[RT]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (RD != 0)
    GPR[RD] = LO;
}


000000,5.RS,5.RT,5.RD,00000,100111:SPECIAL:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = ~ (GPR[RS] | GPR[RT]);
}


000000,5.RS,5.RT,5.RD,00000,100101:SPECIAL:32::OR
"or r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = (GPR[RS] | GPR[RT]);
}


001101,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ORI
"ori r<RT>, r<RS>, <IMMEDIATE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RT] = (GPR[RS] | IMMEDIATE);
}


110011,5.RS,nnnnn,16.OFFSET:NORMAL:32::PREF
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int hint = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	Prefetch(uncached,paddr,vaddr,isDATA,hint);
    }
  }
}

101000,5.BASE,5.RT,16.OFFSET:NORMAL:32::SB
"sb r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 0x7;
	  unsigned int shift = 0;
	  unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	  unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	  unsigned int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	  byte = ((vaddr & mask) ^ (bigend << shift));
	  memval = ((unsigned64) op2 << (8 * byte));
	  {
	    StoreMemory(uncached,AccessLength_BYTE,memval,memval1,paddr,vaddr,isREAL);
	  }
	}
    }
  }
}


111000,5.BASE,5.RT,16.OFFSET:NORMAL:32::SC
"sc r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
	    byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
	    memval = ((unsigned64) op2 << (8 * byte));
	    if (LLBIT)
	      {
		StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
	      }
	    GPR[(instruction >> 16) & 0x0000001F] = LLBIT;
	  }
      }
  }
}


111100,5.BASE,5.RT,16.OFFSET:NORMAL:64::SCD
"scd r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    memval = op2;
	    if (LLBIT)
	      {
		StoreMemory(uncached,AccessLength_DOUBLEWORD,memval,memval1,paddr,vaddr,isREAL);
	      }
	    GPR[(instruction >> 16) & 0x0000001F] = LLBIT;
	  }
      }
  }
}


111111,5.BASE,5.RT,16.OFFSET:NORMAL:64::SD
"sd r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    memval = op2;
	    {
	      StoreMemory(uncached,AccessLength_DOUBLEWORD,memval,memval1,paddr,vaddr,isREAL);
	    }
	  }
      }
  }
}


1111,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:64::SDCz
"sdc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    memval = (unsigned64)COP_SD(((instruction >> 26) & 0x3),destreg);
	    {
	      StoreMemory(uncached,AccessLength_DOUBLEWORD,memval,memval1,paddr,vaddr,isREAL);
	    }
	  }
      }
  }
}


101100,5.BASE,5.RT,16.OFFSET:NORMAL:64::SDL
"sdl r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 7;
	  unsigned int reverse = (ReverseEndian ? mask : 0);
	  unsigned int bigend = (BigEndianCPU ? mask : 0);
	  int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
	  byte = ((vaddr & mask) ^ bigend);
	  if (!BigEndianMem)
	    paddr &= ~mask;
	  memval = (op2 >> (8 * (7 - byte)));
	  StoreMemory(uncached,byte,memval,memval1,paddr,vaddr,isREAL);
	}
    }
  }
}


101101,5.BASE,5.RT,16.OFFSET:NORMAL:64::SDR
"sdr r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word paddr;
  int uncached;
  unsigned64 memval;
  unsigned64 mask = 7;
  unsigned int reverse = (ReverseEndian ? mask : 0);
  unsigned int bigend = (BigEndianCPU ? mask : 0);
  int byte;
  address_word vaddr = (GPR[BASE] + EXTEND16 (OFFSET));
  AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
  if (BigEndianMem)
    paddr &= ~mask;
  byte = ((vaddr & mask) ^ bigend);
  memval = (GPR[RT] << (byte * 8));
  StoreMemory(uncached,(AccessLength_DOUBLEWORD - byte),memval,0,paddr,vaddr,isREAL);
}


101001,5.BASE,5.RT,16.OFFSET:NORMAL:32::SH
"sh r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 1) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int shift = 1;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    memval = ((unsigned64) op2 << (8 * byte));
	    {
	      StoreMemory(uncached,AccessLength_HALFWORD,memval,memval1,paddr,vaddr,isREAL);
	    }
	  }
      }
  }
}


00000000000,5.RT,5.RD,5.SHIFT,000000:SPECIAL:32::SLL
"sll r<RD>, r<RT>, <SHIFT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  int s = SHIFT;
  unsigned32 temp = (GPR[RT] << s);
  GPR[RD] = EXTEND32 (temp);
}


000000,5.RS,5.RT,5.RD,00000000100:SPECIAL:32::SLLV
"sllv r<RD>, r<RT>, r<RS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  int s = MASKED (GPR[RS], 4, 0);
  unsigned32 temp = (GPR[RT] << s);
  GPR[RD] = EXTEND32 (temp);
}


000000,5.RS,5.RT,5.RD,00000101010:SPECIAL:32::SLT
"slt r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = ((signed_word) GPR[RS] < (signed_word) GPR[RT]);
}


001010,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::SLTI
"slti r<RT>, r<RS>, <IMMEDIATE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RT] = ((signed_word) GPR[RS] < (signed_word) EXTEND16 (IMMEDIATE));
}


001011,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::SLTIU
"sltiu r<RT>, r<RS>, <IMMEDIATE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RT] = ((unsigned_word) GPR[RS] < (unsigned_word) EXTEND16 (IMMEDIATE));
}

000000,5.RS,5.RT,5.RD,00000101011:SPECIAL:32::SLTU
"sltu r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT]);
}


000000,00000,5.RT,5.RD,5.SHIFT,000011:SPECIAL:32::SRA
"sra r<RD>, r<RT>, <SHIFT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  int s = SHIFT;
  signed32 temp = (signed32) GPR[RT] >> s;
  GPR[RD] = EXTEND32 (temp);
}


000000,5.RS,5.RT,5.RD,00000000111:SPECIAL:32::SRAV
"srav r<RD>, r<RT>, r<RS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  int s = MASKED (GPR[RS], 4, 0);
  signed32 temp = (signed32) GPR[RT] >> s;
  GPR[RD] = EXTEND32 (temp);
}


000000,00000,5.RT,5.RD,5.SHIFT,000010:SPECIAL:32::SRL
"srl r<RD>, r<RT>, <SHIFT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  int s = SHIFT;
  unsigned32 temp = (unsigned32) GPR[RT] >> s;
  GPR[RD] = EXTEND32 (temp);
}


000000,5.RS,5.RT,5.RD,00000000110:SPECIAL:32::SRLV
"srlv r<RD>, r<RT>, r<RS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  int s = MASKED (GPR[RS], 4, 0);
  unsigned32 temp = (unsigned32) GPR[RT] >> s;
  GPR[RD] = EXTEND32 (temp);
}


000000,5.RS,5.RT,5.RD,00000100010:SPECIAL:32::SUB
"sub r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  ALU32_BEGIN (GPR[RS]);
  ALU32_SUB (GPR[RT]);
  ALU32_END (GPR[RD]);
}


000000,5.RS,5.RT,5.RD,00000100011:SPECIAL:32::SUBU
"subu r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = EXTEND32 (GPR[RS] - GPR[RT]);
}


101011,5.BASE,5.RT,16.OFFSET:NORMAL:32::SW
"sw r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
	    byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
	    memval = ((unsigned64) op2 << (8 * byte));
	    {
	      StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
	    }
	  }
      }
  }
}


1110,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:32::SWCz
"swc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = 0x7;
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
	    byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
	    memval = (((unsigned64)COP_SW(((instruction >> 26) & 0x3),destreg)) << (8 * byte));
	    {
	      StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
	    }
	  }
      }
  }
}


101010,5.BASE,5.RT,16.OFFSET:NORMAL:32::SWL
"swl r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	{
	  unsigned64 memval = 0;
	  unsigned64 memval1 = 0;
	  unsigned64 mask = 3;
	  unsigned int reverse = (ReverseEndian ? mask : 0);
	  unsigned int bigend = (BigEndianCPU ? mask : 0);
	  int byte;
	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
	  byte = ((vaddr & mask) ^ bigend);
	  if (!BigEndianMem)
	    paddr &= ~mask;
	  memval = (op2 >> (8 * (3 - byte)));
	  if ((vaddr & (1 << 2)) ^ (BigEndianCPU << 2)) {
	    memval <<= 32;
	  }
	  StoreMemory(uncached,byte,memval,memval1,paddr,vaddr,isREAL);
	}
    }
  }
}


101110,5.BASE,5.RT,16.OFFSET:NORMAL:32::SWR
"swr r<RT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned64 memval = 0;
  unsigned64 mask = 3;
  unsigned int reverse = (ReverseEndian ? mask : 0);
  unsigned int bigend = (BigEndianCPU ? mask : 0);
  int byte;
  address_word paddr;
  int uncached;
  address_word vaddr = (GPR[BASE] + EXTEND16 (OFFSET));
  AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverse));
  if (BigEndianMem)
    paddr &= ~mask;
  byte = ((vaddr & mask) ^ bigend);
  memval = (GPR[RT] << (byte * 8));
  if ((vaddr & (1 << 2)) ^ (BigEndianCPU << 2))
    memval <<= 32;
  StoreMemory(uncached,(AccessLength_WORD - byte),memval,0,paddr,vaddr,isREAL);
}


000000000000000000000,5.STYPE,001111:SPECIAL:32::SYNC
"sync":STYPE == 0
"sync <STYPE>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  SyncOperation (STYPE);
}


000000,20.CODE,001100:SPECIAL:32::SYSCALL
"syscall <CODE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  SignalException(SystemCall, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110100:SPECIAL:32::TEQ
"teq r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
    SignalException(Trap, instruction_0);
}


000001,5.RS,01100,16.IMMEDIATE:REGIMM:32::TEQI
"teqi r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] == (signed_word) EXTEND16 (IMMEDIATE))
    SignalException(Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110000:SPECIAL:32::TGE
"tge r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
    SignalException(Trap, instruction_0);
}


000001,5.RS,01000,16.IMMEDIATE:REGIMM:32::TGEI
"tgei r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] >= (signed_word) EXTEND16 (IMMEDIATE))
    SignalException(Trap, instruction_0);
}


000001,5.RS,01001,16.IMMEDIATE:REGIMM:32::TGEIU
"tgeiu r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((unsigned_word) GPR[RS] >= (unsigned_word) EXTEND16 (IMMEDIATE))
    SignalException(Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110001:SPECIAL:32::TGEU
"tgeu r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((unsigned_word) GPR[RS] >= (unsigned_word) GPR[RT])
    SignalException(Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110010:SPECIAL:32::TLT
"tlt r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
    SignalException(Trap, instruction_0);
}


000001,5.RS,01010,16.IMMEDIATE:REGIMM:32::TLTI
"tlti r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] < (signed_word) EXTEND16 (IMMEDIATE))
    SignalException(Trap, instruction_0);
}


000001,5.RS,01011,16.IMMEDIATE:REGIMM:32::TLTIU
"tltiu r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((unsigned_word) GPR[RS] < (unsigned_word) EXTEND16 (IMMEDIATE))
    SignalException(Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110011:SPECIAL:32::TLTU
"tltu r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT])
    SignalException(Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110110:SPECIAL:32::TNE
"tne r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
    SignalException(Trap, instruction_0);
}


000001,5.RS,01110,16.IMMEDIATE:REGIMM:32::TNEI
"tne r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  if ((signed_word) GPR[RS] != (signed_word) EXTEND16 (IMMEDIATE))
    SignalException(Trap, instruction_0);
}


000000,5.RS,5.RT,5.RD,00000100110:SPECIAL:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RD] = GPR[RS] ^ GPR[RT];
}


001110,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::XORI
"xori r<RT>, r<RS>, <IMMEDIATE>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  GPR[RT] = GPR[RS] ^ IMMEDIATE;
}


//
// MIPS Architecture:
//
//        FPU Instruction Set (COP1 & COP1X)
//


:%s::::FMT:int fmt
{
  switch (fmt)
    {
    case fmt_single: return "s";
    case fmt_double: return "d";
    case fmt_word: return "w";
    case fmt_long: return "l";
    default: return "?";
    }
}

:%s::::X:int x
{
  switch (x)
    {
    case 0: return "f";
    case 1: return "t";
    default: return "?";
    }
}

:%s::::TF:int tf
{
  if (tf)
    return "t";
  else
    return "f";
}

:%s::::ND:int nd
{
  if (nd)
    return "l";
  else
    return "";
}

:%s::::COND:int cond
{
  switch (cond)
    {
    case 00: return "f";
    case 01: return "un";
    case 02: return "eq";
    case 03: return "ueq";
    case 04: return "olt";
    case 05: return "ult";
    case 06: return "ole";
    case 07: return "ule";
    case 010: return "sf";
    case 011: return "ngle";
    case 012: return "seq";
    case 013: return "ngl";
    case 014: return "lt";
    case 015: return "nge";
    case 016: return "le";
    case 017: return "ngt";
    default: return "?";
    }
}


010001,10,3.FMT,00000,5.FS,5.FD,000101:COP1:32,f::ABS.fmt
"abs.%s<FMT> f<FD>, f<FS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,format,AbsoluteValue(ValueFPR(fs,format),format));
  }
}



010001,10,3.FMT,5.FT,5.FS,5.FD,000000:COP1:32,f::ADD
"add.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction, instruction);
    else
      StoreFPR(destreg,format,Add(ValueFPR(fs,format),ValueFPR(ft,format),format));
  }
}



// BC1F
// BC1FL
// BC1T
// BC1TL

010001,01000,3.0,1.ND,1.TF,16.OFFSET:COP1S:32,f::BC1
"bc1%s<TF>%s<ND> <OFFSET>"
*mipsI,mipsII,mipsIII:
{
  if (PREVCOC1() == TF)
    {
      DELAY_SLOT (NIA + (EXTEND16 (OFFSET) << 2));
    }
  else if (ND)
    {
      NULLIFY_NEXT_INSTRUCTION ();
    }
}

010001,01000,3.CC,1.ND,1.TF,16.OFFSET:COP1S:32,f::BC1
"bc1%s<TF>%s<ND> <OFFSET>":CC == 0
"bc1%s<TF>%s<ND> <CC>, <OFFSET>"
*mipsIV:
*vr5000:
*r3900:
{
  if (GETFCC(CC) == TF)
    {
      DELAY_SLOT (NIA + (EXTEND16 (OFFSET) << 2));
    }
  else if (ND)
    {
      NULLIFY_NEXT_INSTRUCTION ();
    }
}



// C.EQ.S
// C.EQ.D
// ...

:function:::void:do_c_cond_fmt:int fmt, int ft, int fs, int cc, int cond, instruction_word insn
{
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
  else
    {
      int less;
      int equal;
      int unordered;
      int condition;
      unsigned64 ofs = ValueFPR (fs, fmt);
      unsigned64 oft = ValueFPR (ft, fmt);
      if (NaN (ofs, fmt) || NaN (oft, fmt))
	{
	  if (FCSR & FP_ENABLE (IO))
	    {
	      FCSR |= FP_CAUSE (IO);
	      SignalExceptionFPE ();
	    }
	  less = 0;
	  equal = 0;
	  unordered = 1;
	}
      else
	{
	  less = Less (ofs, oft, fmt);
	  equal = Equal (ofs, oft, fmt);
	  unordered = 0;
	}
      condition = (((cond & (1 << 2)) && less)
		   || ((cond & (1 << 1)) && equal)
		   || ((cond & (1 << 0)) && unordered));
      SETFCC (cc, condition);
    }
}

010001,10,3.FMT,5.FT,5.FS,3.0,00,11,4.COND:COP1:32::C.cond.fmt
*mipsI,mipsII,mipsIII:
"c.%s<COND>.%s<FMT> f<FS>, f<FT>":
{
  do_c_cond_fmt (SD_, FMT, FT, FS, 0, COND, instruction_0);
}

010001,10,3.FMT,5.FT,5.FS,3.CC,00,11,4.COND:COP1:32::C.cond.fmt
"c.%s<COND>.%s<FMT> f<FS>, f<FT>":CC == 0
"c.%s<COND>.%s<FMT> <CC>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
*r3900:
{
  do_c_cond_fmt (SD_, FMT, FT, FS, CC, COND, instruction_0);
}


010001,10,3.FMT,00000,5.FS,5.FD,001010:COP1:64::CEIL.L.fmt
"ceil.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_long,Convert(FP_RM_TOPINF,ValueFPR(fs,format),format,fmt_long));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,001110:COP1:32::CEIL.W
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
  else
   StoreFPR(destreg,fmt_word,Convert(FP_RM_TOPINF,ValueFPR(fs,format),format,fmt_word));
  }
}


// CFC1
// CTC1
010001,00,X,10,5.RT,5.FS,00000000000:COP1S:32::CxC1
"c%s<X>c1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{
  if (X)
    {
      if (FS == 0)
	PENDING_FILL((FS + FCR0IDX),VL4_8(GPR[RT]));
      else if (FS == 31)
	PENDING_FILL((FS + FCR31IDX),VL4_8(GPR[RT]));
      /* else NOP */
      PENDING_FILL(COCIDX,0); /* special case */
    }
  else
    { /* control from */
      if (FS == 0)
 	PENDING_FILL(RT,SIGNEXTEND(FCR0,32));
      else if (FS == 31)
 	PENDING_FILL(RT,SIGNEXTEND(FCR31,32));
      /* else NOP */
    }
}
010001,00,X,10,5.RT,5.FS,00000000000:COP1S:32::CxC1
"c%s<X>c1 r<RT>, f<FS>"
*mipsIV:
*vr5000:
*r3900:
{
  if (X)
    {
      if (FS == 0)
	FCR0 = VL4_8(GPR[RT]);
      else if (FS == 31)
	FCR31 = VL4_8(GPR[RT]);
      /* else NOP */
      SETFCC(0,((FCR31 & (1 << 23)) ? 1 : 0));
    }
  else
    { /* control from */
      if (FS == 0)
 	GPR[RT] = SIGNEXTEND (FCR0, 32);
      else if (FS == 31)
 	GPR[RT] = SIGNEXTEND (FCR31, 32);
      /* else NOP */
    }
}


//
// FIXME: Does not correctly differentiate between mips*
//
010001,10,3.FMT,00000,5.FS,5.FD,100001:COP1:32::CVT.D.fmt
"cvt.d.%s<FMT> f<FD>, f<FS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format == fmt_double) | 0)
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_double,Convert(GETRM(),ValueFPR(fs,format),format,fmt_double));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,100101:COP1:64::CVT.L.fmt
"cvt.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format == fmt_long) | ((format == fmt_long) || (format == fmt_word)))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_long,Convert(GETRM(),ValueFPR(fs,format),format,fmt_long));
  }
}


//
// FIXME: Does not correctly differentiate between mips*
//
010001,10,3.FMT,00000,5.FS,5.FD,100000:COP1:32::CVT.S.fmt
"cvt.s.%s<FMT> f<FD>, f<FS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format == fmt_single) | 0)
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_single,Convert(GETRM(),ValueFPR(fs,format),format,fmt_single));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,100100:COP1:32::CVT.W.fmt
"cvt.w.%s<FMT> f<FD>, f<FS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format == fmt_word) | ((format == fmt_long) || (format == fmt_word)))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_word,Convert(GETRM(),ValueFPR(fs,format),format,fmt_word));
  }
}


010001,10,3.FMT,5.FT,5.FS,5.FD,000011:COP1:32::DIV.fmt
"div.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,format,Divide(ValueFPR(fs,format),ValueFPR(ft,format),format));
  }
}


// DMFC1
// DMTC1
010001,00,X,01,5.RT,5.FS,00000000000:COP1S:64::DMxC1
"dm%s<X>c1 r<RT>, f<FS>"
*mipsIII:
{
  if (X)
    {
      if (SizeFGR() == 64)
	PENDING_FILL((FS + FGRIDX),GPR[RT]);
      else if ((FS & 0x1) == 0)
	{
	  PENDING_FILL(((FS + 1) + FGRIDX),VH4_8(GPR[RT]));
	  PENDING_FILL((FS + FGRIDX),VL4_8(GPR[RT]));
	}
    }
  else
    {
      if (SizeFGR() == 64)
	PENDING_FILL(RT,FGR[FS]);
      else if ((FS & 0x1) == 0)
	PENDING_FILL(RT,(SET64HI(FGR[FS+1]) | FGR[FS]));
      else
	PENDING_FILL(RT,SET64HI(0xDEADC0DE) | 0xBAD0BAD0);
    }
}
010001,00,X,01,5.RT,5.FS,00000000000:COP1S:64::DMxC1
"dm%s<X>c1 r<RT>, f<FS>"
*mipsIV:
*vr5000:
*r3900:
{
  if (X)
    {
      if (SizeFGR() == 64)
	StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
      else if ((FS & 0x1) == 0)
	StoreFPR (FS, fmt_uninterpreted_64, SET64HI (FGR[FS+1]) | FGR[FS]);
    }
  else
    {
      if (SizeFGR() == 64)
	GPR[RT] = FGR[FS];
      else if ((FS & 0x1) == 0)
	GPR[RT] = SET64HI (FGR[FS+1]) | FGR[FS];
      else
	GPR[RT] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
    }
}


010001,10,3.FMT,00000,5.FS,5.FD,001011:COP1:64::FLOOR.L.fmt
"floor.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_long,Convert(FP_RM_TOMINF,ValueFPR(fs,format),format,fmt_long));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,001111:COP1:32::FLOOR.W.fmt
"floor.w.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_word,Convert(FP_RM_TOMINF,ValueFPR(fs,format),format,fmt_word));
  }
}


110101,5.BASE,5.FT,16.OFFSET:COP1:64::LDC1
"ldc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word vaddr = GPR[BASE] + EXTEND16 (OFFSET);
  address_word paddr;
  int uncached;
  if ((vaddr & 7) != 0)
    SignalExceptionAddressLoad();
  else
    {
      unsigned64 memval;
      AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL);
      LoadMemory(&memval,0,uncached,AccessLength_DOUBLEWORD,paddr,vaddr,isDATA,isREAL);
      COP_LD(((instruction_0 >> 26) & 0x3),FT,memval);;
    }
}


010011,5.BASE,5.INDEX,5.0,5.FD,000001:COP1X:64::LDXC1
"ldxc1 f<FD>, r<INDEX>(r<BASE>)"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + op2);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    LoadMemory(&memval,&memval1,uncached,AccessLength_DOUBLEWORD,paddr,vaddr,isDATA,isREAL);
	    COP_LD(1,destreg,memval);;
	  }
      }
  }
}



110001,5.BASE,5.FT,16.OFFSET:COP1:32::LWC1 
"lwc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = EXTEND16 (OFFSET);
  int destreg UNUSED = ((instruction >> 16) & 0x0000001F);
  signed_word op1 UNUSED = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((uword64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressLoad();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    uword64 memval = 0;
	    uword64 memval1 = 0;
	    uword64 mask = 0x7;
	    unsigned int shift = 2;
	    unsigned int reverse UNUSED = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend UNUSED = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte UNUSED;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    COP_LW(((instruction >> 26) & 0x3),destreg,(unsigned int)((memval >> (8 * byte)) & 0xFFFFFFFF));
	  }
      }
  }
}


010011,5.BASE,5.INDEX,5.0,5.FD,000000:COP1X:32::LWXC1
"lwxc1 f<FD>, r<INDEX>(r<BASE>)"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
   address_word vaddr = ((unsigned64)op1 + op2);
   address_word paddr;
   int uncached;
   if ((vaddr & 3) != 0)
    SignalExceptionAddressLoad();
   else
   {
    if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    {
     unsigned64 memval = 0;
     unsigned64 memval1 = 0;
     unsigned64 mask = 0x7;
     unsigned int shift = 2;
     unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
     unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
     unsigned int byte;
     paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
     LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
     byte = ((vaddr & mask) ^ (bigend << shift));
     COP_LW(1,destreg,(unsigned int)((memval >> (8 * byte)) & 0xFFFFFFFF));
    }
   }
  }
}



//
// FIXME: Not correct for mips*
//
010011,5.FR,5.FT,5.FS,5.FD,100,001:COP1X:32::MADD.D
"madd.d f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
    StoreFPR(destreg,fmt_double,Add(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double));
  }
}


010011,5.FR,5.FT,5.FS,5.FD,100,000:COP1X:32::MADD.S
"madd.s f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
    StoreFPR(destreg,fmt_single,Add(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single));
  }
}


// MFC1
// MTC1
010001,00,X,00,5.RT,5.FS,00000000000:COP1S:32::MxC1
"m%s<X>c1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{
  if (X)
    { /*MTC1*/
      if (SizeFGR() == 64)
	PENDING_FILL ((FS + FGRIDX), (SET64HI(0xDEADC0DE) | VL4_8(GPR[RT])));
      else
	PENDING_FILL ((FS + FGRIDX), VL4_8(GPR[RT]));
    }
  else /*MFC1*/
    PENDING_FILL (RT, SIGNEXTEND(FGR[FS],32));
}
010001,00,X,00,5.RT,5.FS,00000000000:COP1S:32::MxC1
"m%s<X>c1 r<RT>, f<FS>"
*mipsIV:
*vr5000:
*r3900:
{
  if (X)
    /*MTC1*/
    StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
  else /*MFC1*/
    GPR[RT] = SIGNEXTEND(FGR[FS],32);
}


010001,10,3.FMT,00000,5.FS,5.FD,000110:COP1:32::MOV.fmt
"mov.%s<FMT> f<FD>, f<FS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    StoreFPR(destreg,format,ValueFPR(fs,format));
  }
}


// MOVF
000000,5.RS,3.CC,0,1.TF,5.RD,00000000001:SPECIAL:32::MOVtf
"mov%s<TF> r<RD>, r<RS>, <CC>"
*mipsIV:
*vr5000:
{
  if (GETFCC(CC) == TF)
    GPR[RD] = GPR[RS];
}


// MOVF.fmt
010001,10,3.FMT,3.CC,0,1.TF,5.FS,5.FD,010001:COP1:32::MOVtf.fmt
"mov%s<TF>.%s<FMT> f<FD>, f<FS>, <CC>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int format = ((instruction >> 21) & 0x00000007);
  {
   if (GETFCC(CC) == TF)
     StoreFPR (FD, format, ValueFPR (FS, format));
   else
     StoreFPR (FD, format, ValueFPR (FD, format));
  }
}


010001,10,3.FMT,5.RT,5.FS,5.FD,010011:COP1:32::MOVN.fmt
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    StoreFPR(destreg,format,ValueFPR(fs,format));
  }
}


// MOVT see MOVtf


// MOVT.fmt see MOVtf.fmt



010001,10,3.FMT,5.RT,5.FS,5.FD,010010:COP1:32::MOVZ.fmt
"movz.%s<FMT> f<FD>, f<FS>, r<RT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
   StoreFPR(destreg,format,ValueFPR(fs,format));
  }
}


// MSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,101,001:COP1X:32::MSUB.D
"msub.d f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
    StoreFPR(destreg,fmt_double,Sub(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double));
  }
}


// MSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,101000:COP1X:32::MSUB.S
"msub.s f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
   StoreFPR(destreg,fmt_single,Sub(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single));
  }
}


// MTC1 see MxC1


010001,10,3.FMT,5.FT,5.FS,5.FD,000010:COP1:32::MUL.fmt
"mul.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,format,Multiply(ValueFPR(fs,format),ValueFPR(ft,format),format));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,000111:COP1:32::NEG.fmt
"neg.%s<FMT> f<FD>, f<FS>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,format,Negate(ValueFPR(fs,format),format));
  }
}


// NMADD.fmt
010011,5.FR,5.FT,5.FS,5.FD,110001:COP1X:32::NMADD.D
"nmadd.d f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
   StoreFPR(destreg,fmt_double,Negate(Add(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double),fmt_double));
  }
}


// NMADD.fmt
010011,5.FR,5.FT,5.FS,5.FD,110000:COP1X:32::NMADD.S
"nmadd.s f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
   StoreFPR(destreg,fmt_single,Negate(Add(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single),fmt_single));
  }
}


// NMSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,111001:COP1X:32::NMSUB.D
"nmsub.d f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
   StoreFPR(destreg,fmt_double,Negate(Sub(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double),fmt_double));
  }
}


// NMSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,111000:COP1X:32::NMSUB.S
"nmsub.s f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
  {
    StoreFPR(destreg,fmt_single,Negate(Sub(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single),fmt_single));
  }
}


010011,5.BASE,5.INDEX,5.HINT,00000001111:COP1X:32::PREFX
"prefx <HINT>, r<INDEX>(r<BASE>)"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int fs = ((instruction >> 11) & 0x0000001F);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + (unsigned64)op2);
    address_word paddr;
    int uncached;
    if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
      Prefetch(uncached,paddr,vaddr,isDATA,fs);
  }
}

010001,10,3.FMT,00000,5.FS,5.FD,010101:COP1:32::RECIP.fmt
*mipsIV:
"recip.%s<FMT> f<FD>, f<FS>"
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
  else
   StoreFPR(destreg,format,Recip(ValueFPR(fs,format),format));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,001000:COP1:64::ROUND.L.fmt
"round.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,fmt_long,Convert(FP_RM_NEAREST,ValueFPR(fs,format),format,fmt_long));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,001100:COP1:32::ROUND.W.fmt
"round.w.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
  else
   StoreFPR(destreg,fmt_word,Convert(FP_RM_NEAREST,ValueFPR(fs,format),format,fmt_word));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,010110:COP1:32::RSQRT.fmt
*mipsIV:
"rsqrt.%s<FMT> f<FD>, f<FS>"
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
  else
   StoreFPR(destreg,format,Recip(SquareRoot(ValueFPR(fs,format),format),format));
  }
}


111101,5.BASE,5.FT,16.OFFSET:COP1:64::SDC1
"sdc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  address_word vaddr = GPR[BASE] + EXTEND16 (OFFSET);
  int uncached;
  if ((vaddr & 7) != 0)
    SignalExceptionAddressStore();
  else
    {
      address_word paddr;
      unsigned64 memval;
      AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL);
      memval = (unsigned64) COP_SD(((instruction_0 >> 26) & 0x3),FT);
      StoreMemory(uncached,AccessLength_DOUBLEWORD,memval,0,paddr,vaddr,isREAL);
    }
}



010011,5.RS,5.RT,vvvvv,00000001001:COP1X:64::SDXC1
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int fs = ((instruction >> 11) & 0x0000001F);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((unsigned64)op1 + op2);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    memval = (unsigned64)COP_SD(1,fs);
	    {
	      StoreMemory(uncached,AccessLength_DOUBLEWORD,memval,memval1,paddr,vaddr,isREAL);
	    }
	  }
      }
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,000100:COP1:32::SQRT.fmt
"sqrt.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,format,(SquareRoot(ValueFPR(fs,format),format)));
  }
}


010001,10,3.FMT,5.FT,5.FS,5.FD,000001:COP1:32::SUB.fmt
"sub.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
    else
      StoreFPR(destreg,format,Sub(ValueFPR(fs,format),ValueFPR(ft,format),format));
  }
}



111001,5.BASE,5.FT,16.OFFSET:COP1:32::SWC1
"swc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = EXTEND16 (OFFSET);
  int destreg UNUSED = ((instruction >> 16) & 0x0000001F);
  signed_word op1 UNUSED = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = ((uword64)op1 + offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      SignalExceptionAddressStore();
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    uword64 memval = 0;
	    uword64 memval1 = 0;
	    uword64 mask = 0x7;
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
	    byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
	    memval = (((uword64)COP_SW(((instruction >> 26) & 0x3),destreg)) << (8 * byte));
	    {
	      StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
	    }
	  }
      }
  }
}


010011,5.BASE,5.INDEX,5.FS,00000,001000:COP1X:32::SWXC1
"swxc1 f<FS>, r<INDEX>(r<BASE>)"
*mipsIV:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  int fs = ((instruction >> 11) & 0x0000001F);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
   address_word vaddr = ((unsigned64)op1 + op2);
   address_word paddr;
   int uncached;
   if ((vaddr & 3) != 0)
    SignalExceptionAddressStore();
   else
   {
    if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    {
     unsigned64 memval = 0;
     unsigned64 memval1 = 0;
     unsigned64 mask = 0x7;
     unsigned int byte;
     paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
     byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
     memval = (((unsigned64)COP_SW(1,fs)) << (8 * byte));
      {
       StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
      }
    }
   }
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,001001:COP1:64::TRUNC.L.fmt
"trunc.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
  else
   StoreFPR(destreg,fmt_long,Convert(FP_RM_TOZERO,ValueFPR(fs,format),format,fmt_long));
  }
}


010001,10,3.FMT,00000,5.FS,5.FD,001101:COP1:32::TRUNC.W
"trunc.w.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
  else
   StoreFPR(destreg,fmt_word,Convert(FP_RM_TOZERO,ValueFPR(fs,format),format,fmt_word));
  }
}


//
// MIPS Architecture:
//
//        System Control Instruction Set (COP0)
//


010000,01000,00000,16.OFFSET:COP0:32::BC0F
"bc0f <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


010000,01000,00010,16.OFFSET:COP0:32::BC0FL
"bc0fl <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


010000,01000,00001,16.OFFSET:COP0:32::BC0T
"bc0t <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:



010000,01000,00011,16.OFFSET:COP0:32::BC0TL
"bc0tl <OFFSET>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


101111,5.BASE,5.OP,16.OFFSET:NORMAL:32::CACHE
*mipsIII:
*mipsIV:
*vr5000:
*r3900:
{
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int hint = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
  {
    address_word vaddr = (op1 + offset);
    address_word paddr;
    int uncached;
    if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
      CacheOp(hint,vaddr,paddr,instruction);
  }
}


010000,10000,000000000000000,111001:COP0:32::DI
"di"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


010000,10000,000000000000000,111000:COP0:32::EI
"ei"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


010000,10000,000000000000000,011000:COP0:32::ERET
"eret"
*mipsIII:
*mipsIV:
*vr5000:


010000,00000,5.RT,5.RD,00000,6.REGX:COP0:32::MFC0
"mfc0 r<RT>, r<RD> # <REGX>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
{
  DecodeCoproc (instruction_0);
}

010000,00100,5.RT,5.RD,00000,6.REGX:COP0:32::MTC0
"mtc0 r<RT>, r<RD> # <REGX>"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:
{
  DecodeCoproc (instruction_0);
}


010000,10000,000000000000000,001000:COP0:32::TLBP
"tlbp"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


010000,10000,000000000000000,000001:COP0:32::TLBR
"tlbr"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


010000,10000,000000000000000,000010:COP0:32::TLBWI
"tlbwi"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


010000,10000,000000000000000,000110:COP0:32::TLBWR
"tlbwr"
*mipsI,mipsII,mipsIII,mipsIV:
*vr5000:


:include:::m16.igen

