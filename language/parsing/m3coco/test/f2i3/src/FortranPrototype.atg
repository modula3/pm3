(* Grammar for Fortran that cares about the procedure prototypes only *)

(*
  I cannot see how one can handle multi-lines and comments
  with this Grammar.
  I suggest preprocessing the files with regular expression search&replace.
  Unfortunately 'sed','perl' & co. have their problems with regular expressions
  that matches patterns across line breaks.
  With Nedit there is no problem:

   Turn Multi-lines into single ones:
     replace: \n *\$
     by: (nothing)

   Remove all comments that carry no interesting information
     replace: (\* +\w+ +\(.*?(input|output|workspace).*?\)).*(\n)|(\*.*\n)|(.*\n)
     by:      \1\3\5

   perl -p -e "s/(\* +\w+ +\(.*?(input|output|workspace).*?\)).*(\n)|(\*.*\n)|(.*\n)/\1\3\5/"
*)

COMPILER FortranPrototype

IMPORT IO;

CHARACTERS
  letter  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
          + "abcdefghijklmnopqrstuvwxyz" .
  octal   = "01234567" .
  digit   = "0123456789" .
  hex     = "0123456789abcdefABCDEF" .
  space   = " " + CHR(9) + CHR(10) + CHR(13) .
  other   = "!#$%&()*+,-./:;<=>?@[]^_{|}" + CHR(128) .. CHR(255) .
  exp     = "EeDdXx" .
  esc     = "ntrf\'" + '"' .
  print   = letter + digit + other .
  eol     = CHR(10) .

TOKENS
  id      = letter {letter | digit | "_"} .
  number  = digit {digit} ["." {digit} [exp ["+"|"-"] digit {digit}] ] .
  charlit = "'" (print | "\" (esc | octal octal octal) | '"') "'" .
  textlit = '"' {print | "\" (esc | octal octal octal) | "'"} '"' .
  trash   = other .
(*  symbol  = "<" | ">" | "=" | ">=" | "<=" . *)
  newline = eol .

(* comments may only start at the beginning of a line
COMMENTS FROM "*" TO eol
*)

PRODUCTIONS

(* Compilation unit productions *)

FortranPrototype = Procedure .

(* Unfortunately we have to parse comments,
   and sometimes the parser will complain about strings it can't classify.
   "(" | ")" | "," can't be integrated in  the definition of 'trash'
   probably because e.g. "(" is used as special string somewhere.
Comment = {"*" {id | number | trash | "(" | ")" | "," | "=" | "*"} newline} .
*)

LineSep = newline .

Procedure = (SubroutineHead | FunctionHead) Declarations TypeComments .

SubroutineHead      (. VAR name,sig : TEXT; .)
   = "SUBROUTINE" Ident<name> Signature<sig> LineSep
	(. IO.Put("PROCEDURE "&name&sig&";\n") .) .

FunctionHead        (. VAR name,sig,rettype : TEXT; .)
   = Type<rettype> "FUNCTION" Ident<name> Signature<sig> LineSep
	(. IO.Put("PROCEDURE "&name&sig&":"&rettype&";\n") .) .

Declarations                   (. VAR type,var : TEXT; .)
   = { (
         "EXTERNAL"
         Ident<var>            (. IO.Put("(* Procedure "&var&" *)\n") .)
         {"," Ident<var>       (. IO.Put("(* Procedure "&var&" *)\n") .)
         }
       |
         Type<type>
         VarDecl<var>          (. IO.Put(var&type&";\n") .)
         {"," VarDecl<var>     (. IO.Put(var&type&";\n") .)
         }
       )
       LineSep
     } .

VarDecl<VAR var:TEXT>          (. VAR name, dim : TEXT; typecons:=""; .)
   = Ident<name>
     ["(" ArrDim<dim>          (. typecons := "ARRAY "&dim&"OF " .)
      {"," ArrDim<dim>         (. typecons := "ARRAY "&dim&"OF "&typecons .)
      }                        (. typecons := "(* "&typecons&"*) " .)
      ")"]                     (. var := name&": "&typecons .)
     .

ArrDim<VAR dim:TEXT>           (. VAR id : TEXT; .)
   = "*"                       (. dim:="" .)
   | Ident<id>                 (. dim:="[0.."&id&"-1] " .)
   .

Signature<VAR sig:TEXT>        (. VAR formal:TEXT; .)
   = "("                       (. sig:="(" .)
       [Ident<formal>          (. sig:="("&formal .)
       {"," Ident<formal>      (. sig:=sig&"; "&formal .)
       }]                      (. sig:=sig&")" .)
     ")" .

Type<VAR type : TEXT;> = BuiltinType<type> .

BuiltinType<VAR type : TEXT;>
   = "LOGICAL"      (. type := "BOOLEAN" .)
   | "CHARACTER"    (. type := "CHAR" .)
   | "INTEGER"      (. type := "INTEGER" .)
   | ("DOUBLE"      (. type := "LONGREAL" .)
     |"SINGLE"      (. type := "REAL" .)
     ) "PRECISION"
   .

TypeComments        (. VAR writeable :BOOLEAN; id:TEXT; .)
   = {"*" Ident<id>
              (. writeable:=FALSE .)
          "(" ParamMode<writeable> | {"/" ParamMode<writeable>} ")"
              (. IO.Put(ARRAY BOOLEAN OF TEXT{"READONLY","VAR"}[writeable] & " " & id & "\n") .)
     LineSep } .

ParamMode<VAR writeable:BOOLEAN>
   = "input"
   | "output"     (. writeable:=TRUE .)
   | "workspace"  (. writeable:=TRUE .)
   .

Ident <VAR t:TEXT;> = id (. t := p.string() .).

(*
ProcedureBody = Assignment Trash .

Assignment    = id "=" id .

Trash         = {trash} .
*)

END FortranPrototype.
