(* Grammar for Fortran that cares about the procedure prototypes only *)

(*
  I cannot see how one can handle multi-lines and comments
  with this Grammar.
  I suggest preprocessing the files with regular expression search&replace.
  Unfortunately 'sed','perl' & co. have their problems with regular expressions
  that matches patterns across line breaks.
  With Nedit there is no problem:

   Turn Multi-lines into single ones:
     replace: \n *\$
     by: (nothing)

   Remove all comments that carry no interesting information
     replace: (\* +\w+ +\(.*?(input|output|workspace).*?\)).*(\n)|(\*.*\n)|(.*\n)
     by:      \1\3\5

   perl -p -e "s/(\* +\w+ +\(.*?(input|output|workspace).*?\)).*(\n)|(\*.*\n)|(.*\n)/\1\3\5/"
*)

COMPILER FortranPrototype

IMPORT IO, ParamTbl, TextList;

CHARACTERS
  letter  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
          + "abcdefghijklmnopqrstuvwxyz" .
  octal   = "01234567" .
  digit   = "0123456789" .
  hex     = "0123456789abcdefABCDEF" .
  space   = " " + CHR(9) + CHR(10) + CHR(13) .
  other   = "!#$%&()*+,-./:;<=>?@[]^_{|}" + CHR(128) .. CHR(255) .
  exp     = "EeDdXx" .
  esc     = "ntrf\'" + '"' .
  print   = letter + digit + other .
  eol     = CHR(10) .

TOKENS
  id      = letter {letter | digit | "_"} .
  number  = digit {digit} ["." {digit} [exp ["+"|"-"] digit {digit}] ] .
  charlit = "'" (print | "\" (esc | octal octal octal) | '"') "'" .
  textlit = '"' {print | "\" (esc | octal octal octal) | "'"} '"' .
  trash   = other .
(*  symbol  = "<" | ">" | "=" | ">=" | "<=" . *)
  newline = eol .

(* comments may only start at the beginning of a line
COMMENTS FROM "*" TO eol
*)

PRODUCTIONS

(* Compilation unit productions *)

FortranPrototype = Procedure .

Procedure
(. VAR
     params    : TextList.T := NIL;
     paramInfo := NEW(ParamTbl.Default).init(10);
     name      : TEXT;
     rettype   := "";
.)
   = (SubroutineHead<name> | FunctionHead<name,rettype>)
     Signature<params> newline
     Declarations
     TypeComments
     (.
       IO.Put("PROCEDURE "&name&" (");
       params := TextList.ReverseD(params);
       VAR p:=params;
       BEGIN
         WHILE p#NIL DO
           IO.Put(p.head&": "&"; ");
           p:=p.tail;
         END;
       END;
       IO.Put(")"&rettype&"\n")
     .)
   .

SubroutineHead<VAR name : TEXT;>
   = "SUBROUTINE" Ident<name> .

FunctionHead<VAR name,rettype : TEXT;>
   = Type<rettype> "FUNCTION" Ident<name> .

Signature<VAR params : TextList.T>   (. VAR formal:TEXT; .)
   = "("
       [Ident<formal>          (. params:=TextList.Cons(formal,params) .)
       {"," Ident<formal>      (. params:=TextList.Cons(formal,params) .)
       }]
     ")" .

Declarations                   (. VAR type,var : TEXT; .)
   = { (
         "EXTERNAL"
         Ident<var>            (. IO.Put("(* Procedure "&var&" *)\n") .)
         {"," Ident<var>       (. IO.Put("(* Procedure "&var&" *)\n") .)
         }
       |
         Type<type>
         VarDecl<var>          (. IO.Put(var&type&";\n") .)
         {"," VarDecl<var>     (. IO.Put(var&type&";\n") .)
         }
       )
       newline
     } .

VarDecl<VAR var:TEXT>          (. VAR name, dim : TEXT; typecons:=""; .)
   = Ident<name>
     ["(" ArrDim<dim>          (. typecons := "ARRAY "&dim&"OF " .)
      {"," ArrDim<dim>         (. typecons := "ARRAY "&dim&"OF "&typecons .)
      }                        (. typecons := "(* "&typecons&"*) " .)
      ")"]                     (. var := name&": "&typecons .)
     .

ArrDim<VAR dim:TEXT>           (. VAR id : TEXT; .)
   = "*"                       (. dim:="" .)
   | Ident<id>                 (. dim:="[0.."&id&"-1] " .)
   .

Type<VAR type : TEXT;> = BuiltinType<type> .

BuiltinType<VAR type : TEXT;>
   = "LOGICAL"      (. type := "BOOLEAN" .)
   | "CHARACTER"    (. type := "CHAR" .)
   | "INTEGER"      (. type := "INTEGER" .)
   | ("DOUBLE"      (. type := "LONGREAL" .)
     |"SINGLE"      (. type := "REAL" .)
     ) "PRECISION"
   .

TypeComments        (. VAR writeable :BOOLEAN; id:TEXT; .)
   = {"*" Ident<id>
              (. writeable:=FALSE .)
          "(" ParamMode<writeable> | {"/" ParamMode<writeable>} ")"
              (. IO.Put(ARRAY BOOLEAN OF TEXT{"READONLY","VAR"}[writeable] & " " & id & "\n") .)
     newline } .

ParamMode<VAR writeable:BOOLEAN>
   = "input"
   | "output"     (. writeable:=TRUE .)
   | "workspace"  (. writeable:=TRUE .)
   .

Ident <VAR t:TEXT;> = id (. t := p.string() .).

END FortranPrototype.
