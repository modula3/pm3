\section{xWordEx: Extensions to Word}
[Warren D. Smith (wds@research.NJ.NEC.COM) provided the
analysis and the module.]

It has often struck me as outrageous that most higher level
languages do not allow you to access the fundamental machine-language
primitives for add-with-carry, subtract-with-borrow, shift-with-carry,
multiply-to-get-a-double-length-product, and
double-length-divide-with-remainder. In addition, 
I think syntactic sugar should be added to m3 for:
\begin{description}
\item[SWAP(x,y)] Swapping 2 words.
\item[SQUARE(x)] Squaring a number.
\end{description}

These are necessary for writing a bignum package or a linear congruential
random number generator.

Also, it annoys me that more hardware does not provide the (cray)
machine language primitives (very useful for SETs as boolean vectors as words!)
\begin{description}
\item[PopCount(x)] Returns number of 1s in binary representation of x
\item[FindLeastSignifBit(x)]  Returns index of the least significant
bit of x that is a 1
\item[FindMostSignifBit(x)]  Returns index of the  most significant
bit of x (often can be done thru conversion to floating
point in normalized form, by the way)
\end{description}

But even if you ARE on such hardware, you can't get at the primitives
in your high-level language. Very annoying again. I claim there is a vicious
cycle here: hardware designers observe that compiled code has no PopCount()
calls so they omit it from their next processor design, and software
designers see no reason to provide it since it is not in the hardware!
How silly - in fact these are very useful.

So MY SUGGESTION is that these functions be added to modula-3 as an
enhancement to the "Word" library, in such a way that the compiler
will compile them into the appropriate machine language instructions!!

View this as a selling point of modula-3 - the language that actually
helps you to use your machine rather than preventing you!!

However, as a stopgap measure, I provide a software
implementation, which the compiler could resort to until such
point as the compiler writers provide code-generation support.

[See module for implementations.]
