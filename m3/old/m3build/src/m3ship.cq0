local script = [
  "/* Copyright (C) 1994, Digital Equipment Corporation           */",
  "/* All rights reserved.                                        */",
  "/* See the file COPYRIGHT for a full description.              */",
  "",
  "/* Last modified on Wed Aug 30 16:40:05 PDT 1995 by steveg     */",
  "/*      modified on Wed Nov 30 14:04:47 PST 1994 by kalsow     */",
  "",
  "/*   original shell script written by Bill Kalsow (1993)       */",
  "/*   translated to C by Klaus Preschen (1994)                  */",
  "/*      (Postfach 38, A-9170 Ferlach, Austria)                 */",
  "/*      (e-mail: Preschern@edvz.uni-klagenfurt.ada.at)         */",
  "",
  "#include <stdio.h>",
  "#include <stdlib.h>",
  "#include <string.h>",
  "#include <sys/types.h>",
  "#include <sys/stat.h>",
  "#ifdef WIN32",
  "#  include <process.h>",
  "#  include <direct.h>",
  "#  define  dircmp(a,b) _stricmp((a),(b))",
  "#else",
  "#  define  dircmp(a,b) strcmp((a),(b))",
  "#endif",
  "#ifdef NeXT",
  "#  include \"../src/getcwd.c\"",
  "#endif",
  "",
  "#define DEBUG        0",
  "#define PATH_LEN     1024",
  "",
  "#if DEBUG",
  "#define DPRINTF(args) printf args;",
  "#else",
  "#define DPRINTF(args)",
  "#endif",
  "",
  "static char ship_partial = 0;",
  "static char verbose      = 0;",
  "static char quiet        = 0;",
  "static char do_it        = 1;",
  "",
  "static char *derived_directories [] = {",
  " /*  \"DSC\", */",
  "  \"DS\",",
  "  \"NT386\",",
  " /* \"ALPHA_OSF\", */",
  "  \"AOSF\",",
  "  0 };",
  "",
  "static char *tidy_cmd [] = {",
  "  \"find\", \".\", \"(\", \"-name\", \",*\",",
  "  \"-o\", \"-name\", \".,*\",",
  "  \"-o\", \"-name\", \".emacs_[0-9]*\",",
  "  \"-o\", \"-name\", \"*~\",",
  "  \"-o\", \"-name\", \"core\",",
  "  \"-o\", \"-name\", \"a.out\",",
  "  \"-o\", \"-name\", \".m3path*\",",
  "  \"-o\", \"-name\", \".m3imports*\",",
  "  \")\", \"-exec\", \"rm\", \"-f\", \"{}\", \";\",",
  "  0 };",
  "",
  "static int n_ship_args = 2;",
  "static char *ship_cmd [128] = {",
  "  \"shippackage\", \"m3/\",",
  "  0 };",
  "",
  "static int readable (name)",
  "  char *name;",
  "  {",
  "    /* we do not check for readability, just for existence */",
  "    struct stat statbuf;",
  "    DPRINTF((\"readable (%s)\\n\", name))",
  "    return (!(stat (name, &statbuf) < 0));",
  "  }",
  "",
  "static char * dircat (dir1, dir2)",
  "  char *dir1;",
  "  char *dir2;",
  "  {",
  "    int   len1 = strlen (dir1);",
  "    int   len2 = strlen (dir2);",
  "    char *new  = (char*)malloc (len1 + len2 + 2);",
  "    strcpy (new, dir1);",
  "    strcat (new, \"" & escape (SL) & "\");",
  "    strcat (new, dir2);",
  "    DPRINTF ((\"dircat (%s, %s) => %s\\n\", dir1, dir2, new))",
  "    return new;",
  "  }",
  "",
  "static void print_usage ()",
  "  {",
  "    printf (\"usage: m3ship [options]\\n\");",
  "    printf (\"  -k        ship partial\\n\");",
  "    printf (\"  -q        quiet\\n\");",
  "    printf (\"  -v        verbose\\n\");",
  "    printf (\"  -n        don't actually ship\\n\");",
  "    printf (\"  -help     print this messsage\\n\");",
  "    printf (\"  -version  print version\\n\");",
  "    printf (\"\\n\");",
  "  }",
  "",
  "/*",
  " * parse the command line",
  " */",
  "",
  "static void parse_command_line (argc, argv)",
  "  int   argc;",
  "  char **argv;",
  "  {",
  "    int i = 1;",
  "    while (i < argc) {",
  "      if (strcmp (argv [i], \"-k\") == 0) {",
  "        ship_partial = 1;",
  "      } else if (strcmp (argv [i], \"-q\") == 0) {",
  "        quiet = 1;  verbose = 0;",
  "      } else if (strcmp (argv [i], \"-v\") == 0) {",
  "        quiet = 0;  verbose = 1;",
  "      } else if (strcmp (argv [i], \"-n\") == 0) {",
  "        verbose = 1;",
  "        do_it = 0;",
  "      } else if (strcmp (argv [i], \"-version\") == 0) {",
  "        printf (\"m3ship: " & M3_VERSION & "\\n\");",
  "        exit (0);",
  "      } else if (strcmp (argv [i], \"-h\") == 0) {",
  "        print_usage ();",
  "        exit (0);",
  "      } else if (strcmp (argv [i], \"-help\") == 0) {",
  "        print_usage ();",
  "        exit (0);",
  "      } else if (strcmp (argv [i], \"-?\") == 0) {",
  "        print_usage ();",
  "        exit (0);",
  "      } else {",
  "        printf (\"m3ship: unrecognized option: %s\\n\", argv [i]);",
  "        print_usage ();",
  "        exit (-1);",
  "      }",
  "      i++;",
  "    }",
  "    DPRINTF((\" --------------------------- \\n\"))",
  "    for (i = 0; i < argc; i++) {",
  "      DPRINTF((\" argv [%d] = %s\\n\", i, argv [i]))",
  "    }",
  "    DPRINTF((\" --------------------------- \\n\"))",
  "  }",
  "",
  "static char * basename (name)",
  "  char *name;",
  "  {",
  "    int i, len;",
  "    char *p, *base, *last_sep = name-1;",
  "    for (p = name; *p; p++) {",
  "      if (*p == '" & escape (SL) & "') last_sep = p;",
  "    };",
  "    last_sep++;",
  "    len = p - last_sep;",
  "    base = (char*)malloc (len + 1);",
  "    strcpy (base, last_sep);",
  "    DPRINTF((\"basename (%s) = %s\\n\", name, base))",
  "    return base;",
  "  }",
  "",
  "static void get_package ()",
  "  {",
  "    char dir [PATH_LEN];",
  "    char *package;",
  "    getcwd (dir, PATH_LEN);",
  "    package = basename (dir);",
  "    if (dircmp (package, \"src\") == 0) {",
  "      chdir (\"..\");",
  "      getcwd (dir, PATH_LEN);",
  "      package = basename (dir);",
  "    }",
  "    ship_cmd[1] = dircat (\"m3\", package);", 
  "    DPRINTF((\"package = %s\\n\", package))",
  "  }",
  "",
  "/*",
  " * check for an overrides file",
  " */",
  "static void check_for_overrides_file (dir)",
  "  char *dir;",
  "  {",
  "    if (! ship_partial) {",
  "      if (readable (dircat (dir, \".M3OVERRIDES\"))) {",
  "        printf (\"m3ship: package built with overrides - not shipping\\n\");",
  "        exit (-1);",
  "      }",
  "    }",
  "  }",
  "",
  "/*",
  " * check for a .M3SHIP file",
  " */",
  "static void find_shipfile (dir)",
  "  char *dir;",
  "  {",
  "    char *fname;",
  "    fname = dircat (dir, \".M3SHIP\");",
  "    if (readable (fname)) {",
  "      ship_cmd [n_ship_args++] = \"-file\";",
  "      ship_cmd [n_ship_args++] = fname;",
  "    }",
  "  }",
  "",
  "/*",
  " * check for .M3SHIP files",
  " */",
  "static void find_shipfiles ()",
  "  {",
  "    int i;",
  "    for (i = 0; derived_directories[i]; i++) {",
  "      check_for_overrides_file (derived_directories[i]);",
  "      find_shipfile (derived_directories[i]);",
  "    };",
  "  }",
  "",
  "static void run (cmd)",
  "  char ** cmd;",
  "  {",
  "     int i, status;",
  "",
  "     if (verbose) {",
  "       for (i = 0; cmd[i]; i++) {",
  "         if (i) printf (\" \");",
  "         printf (cmd[i]);",
  "       };",
  "       printf(\"\\n\");",
  "     };",
  "",
  "     fflush(stdout);",
  "     fflush(stderr);",
  "",
  "     if (do_it) {",
  "#ifdef WIN32",
  "       status = spawnvp (_P_WAIT, cmd[0], cmd);",
  "#else",
  "       if (vfork () == 0) {",
  "         /* child */",
  "         if (execvp (cmd[0], cmd) < 0) {",
  "           printf (\"m3ship: cannot execute %s\\n\", cmd[0]);",
  "           exit (-1);",
  "         }",
  "       }",
  "       /* parent */",
  "       wait (&status);",
  "#endif",
  "     };",
  "",
  "     if (status != 0) {",
  "       printf (\"m3ship: %s failed (status = %d)\\n\", cmd[0], status);",
  "       exit (-1);",
  "     };",
  "  }",
  "",
  "int main (argc, argv, envp)",
  "  int    argc;",
  "  char **argv;",
  "  char **envp;",
  "  {",
  "    parse_command_line (argc, argv);",
  "    get_package ();",
  "    run (tidy_cmd);",
  "    find_shipfiles ();",
  "    run (ship_cmd);",
  "    return 0;",
  "  }",
  ""
]
