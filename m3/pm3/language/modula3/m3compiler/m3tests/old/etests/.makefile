# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.48 89/10/10 18:33:21 jim Exp $

CPU_TYPE = mips
ARCH     = DS3100

UILIB     = -lm3ui -lm3X11 -lX11 -lpropertyset -lm3table
SHOWHEAP  = /proj/cra/ultrix/$(CPU_TYPE)/lib/m3/ShowHeap.io \
            /proj/cra/ultrix/$(CPU_TYPE)/lib/m3/ShowHeap.mo
X11LIBS   = -L/src/mips/lib -lXaw -lXmu -lXext -lXt -lX11
M3X11LIBS = -lm3Xaw -lm3Xt -lm3X11 $(X11LIBS)

all::

M3        = m3xx
M3FLAGS   = -w1 -make -why
M3OPT     = -g
M3DEFPATH =
M3LIBPATH =
DO_M3     = $(M3) $(M3FLAGS) $(M3OPT) $(M3DEFPATH) $(M3LIBPATH)

.pkgs:: m3makefile ;\
  @echo "building import links..." ;\
  /bin/rm -rf .pkgs ;\
  mkdir .pkgs ;\
  pkgnames="$(PACKAGES)" ;\
  for PKG in $$pkgnames; do (\
     echo "   " $$PKG ;\
     m3mkpath .pkgs/$$PKG ;\
     /bin/rm -f .pkgs/$$PKG ;\
     ln -s  /proj/packages/m3$$PKG .pkgs/$$PKG \
  ); done

wrap::
unwrap::

M3      = m3xx -Y0@/udir/kalsow/m3/m3compiler/mips/m3compiler@
M3FLAGS =
COMPILE = $(M3) -g -w1 -D../.. -o a.out ../libtest.a

all::
new_base::
tidy::
scratch::

libtest.a: ../Test.i3 ../Test.m3 ; $(M3) -a libtest.a ../Test.i3 ../Test.m3
scratch:: ; -rm -f libtest.a Test.io Test.mo

all:: e001_X
new_base:: e001_base
scratch:: ; -rm -fr e001_X
e001:: e001_X
e001_base:: e001_X ; @mv e001_X/stdout e001_X/stderr e001
e001_X:: libtest.a FRC ;\
-@ echo --- e001 ---  "assigning non-overlapping subrange types"  ;\
   rm -fr e001_X ;\
   mkdir e001_X ;\
   (cd e001_X ;\
     $(COMPILE) ../e001 >stdout ) 1>2 2>e001_X/stderr ;\
   diff e001/stdout e001_X/stdout ;\
   diff e001/stderr e001_X/stderr ;\
   rm -f e001_X/a.out

all:: e002_X
new_base:: e002_base
scratch:: ; -rm -fr e002_X
e002:: e002_X
e002_base:: e002_X ; @mv e002_X/stdout e002_X/stderr e002
e002_X:: libtest.a FRC ;\
-@ echo --- e002 ---  "non-constant variable initialization in an interface"  ;\
   rm -fr e002_X ;\
   mkdir e002_X ;\
   (cd e002_X ;\
     $(COMPILE) ../e002 >stdout ) 1>2 2>e002_X/stderr ;\
   diff e002/stdout e002_X/stdout ;\
   diff e002/stderr e002_X/stderr ;\
   rm -f e002_X/a.out

all:: e003_X
new_base:: e003_base
scratch:: ; -rm -fr e003_X
e003:: e003_X
e003_base:: e003_X ; @mv e003_X/stdout e003_X/stderr e003
e003_X:: libtest.a FRC ;\
-@ echo --- e003 ---  "exception not at the top-level"  ;\
   rm -fr e003_X ;\
   mkdir e003_X ;\
   (cd e003_X ;\
     $(COMPILE) ../e003 >stdout ) 1>2 2>e003_X/stderr ;\
   diff e003/stdout e003_X/stdout ;\
   diff e003/stderr e003_X/stderr ;\
   rm -f e003_X/a.out

all:: e004_X
new_base:: e004_base
scratch:: ; -rm -fr e004_X
e004:: e004_X
e004_base:: e004_X ; @mv e004_X/stdout e004_X/stderr e004
e004_X:: libtest.a FRC ;\
-@ echo --- e004 ---  "Text.Cat with the wrong number of arguments"  ;\
   rm -fr e004_X ;\
   mkdir e004_X ;\
   (cd e004_X ;\
     $(COMPILE) ../e004 >stdout ) 1>2 2>e004_X/stderr ;\
   diff e004/stdout e004_X/stdout ;\
   diff e004/stderr e004_X/stderr ;\
   rm -f e004_X/a.out

all:: e005_X
new_base:: e005_base
scratch:: ; -rm -fr e005_X
e005:: e005_X
e005_base:: e005_X ; @mv e005_X/stdout e005_X/stderr e005
e005_X:: libtest.a FRC ;\
-@ echo --- e005 ---  "/ instead of DIV on CARDINAL constants"  ;\
   rm -fr e005_X ;\
   mkdir e005_X ;\
   (cd e005_X ;\
     $(COMPILE) ../e005 >stdout ) 1>2 2>e005_X/stderr ;\
   diff e005/stdout e005_X/stdout ;\
   diff e005/stderr e005_X/stderr ;\
   rm -f e005_X/a.out

all:: e006_X
new_base:: e006_base
scratch:: ; -rm -fr e006_X
e006:: e006_X
e006_base:: e006_X ; @mv e006_X/stdout e006_X/stderr e006
e006_X:: libtest.a FRC ;\
-@ echo --- e006 ---  "non-imported exceptions are visible !"  ;\
   rm -fr e006_X ;\
   mkdir e006_X ;\
   (cd e006_X ;\
     $(COMPILE) ../e006 >stdout ) 1>2 2>e006_X/stderr ;\
   diff e006/stdout e006_X/stdout ;\
   diff e006/stderr e006_X/stderr ;\
   rm -f e006_X/a.out

all:: e007_X
new_base:: e007_base
scratch:: ; -rm -fr e007_X
e007:: e007_X
e007_base:: e007_X ; @mv e007_X/stdout e007_X/stderr e007
e007_X:: libtest.a FRC ;\
-@ echo --- e007 ---  "procedure constants (no longer an error...)"  ;\
   rm -fr e007_X ;\
   mkdir e007_X ;\
   (cd e007_X ;\
     $(COMPILE) ../e007 >stdout ) 1>2 2>e007_X/stderr ;\
   diff e007/stdout e007_X/stdout ;\
   diff e007/stderr e007_X/stderr ;\
   rm -f e007_X/a.out

all:: e008_X
new_base:: e008_base
scratch:: ; -rm -fr e008_X
e008:: e008_X
e008_base:: e008_X ; @mv e008_X/stdout e008_X/stderr e008
e008_X:: libtest.a FRC ;\
-@ echo --- e008 ---  "circular imports"  ;\
   rm -fr e008_X ;\
   mkdir e008_X ;\
   (cd e008_X ;\
     $(COMPILE) ../e008 >stdout ) 1>2 2>e008_X/stderr ;\
   diff e008/stdout e008_X/stdout ;\
   diff e008/stderr e008_X/stderr ;\
   rm -f e008_X/a.out

all:: e009_X
new_base:: e009_base
scratch:: ; -rm -fr e009_X
e009:: e009_X
e009_base:: e009_X ; @mv e009_X/stdout e009_X/stderr e009
e009_X:: libtest.a FRC ;\
-@ echo --- e009 ---  "method specified in NEW incompatible with type declaration"  ;\
   rm -fr e009_X ;\
   mkdir e009_X ;\
   (cd e009_X ;\
     $(COMPILE) ../e009 >stdout ) 1>2 2>e009_X/stderr ;\
   diff e009/stdout e009_X/stdout ;\
   diff e009/stderr e009_X/stderr ;\
   rm -f e009_X/a.out

all:: e010_X
new_base:: e010_base
scratch:: ; -rm -fr e010_X
e010:: e010_X
e010_base:: e010_X ; @mv e010_X/stdout e010_X/stderr e010
e010_X:: libtest.a FRC ;\
-@ echo --- e010 ---  "verify that there are enough elements in an array constructor"  ;\
   rm -fr e010_X ;\
   mkdir e010_X ;\
   (cd e010_X ;\
     $(COMPILE) ../e010 >stdout ) 1>2 2>e010_X/stderr ;\
   diff e010/stdout e010_X/stdout ;\
   diff e010/stderr e010_X/stderr ;\
   rm -f e010_X/a.out

all:: e011_X
new_base:: e011_base
scratch:: ; -rm -fr e011_X
e011:: e011_X
e011_base:: e011_X ; @mv e011_X/stdout e011_X/stderr e011
e011_X:: libtest.a FRC ;\
-@ echo --- e011 ---  "m3compiler accepts any type for VAR ARRAY OF formal"  ;\
   rm -fr e011_X ;\
   mkdir e011_X ;\
   (cd e011_X ;\
     $(COMPILE) ../e011 >stdout ) 1>2 2>e011_X/stderr ;\
   diff e011/stdout e011_X/stdout ;\
   diff e011/stderr e011_X/stderr ;\
   rm -f e011_X/a.out

all:: e012_X
new_base:: e012_base
scratch:: ; -rm -fr e012_X
e012:: e012_X
e012_base:: e012_X ; @mv e012_X/stdout e012_X/stderr e012
e012_X:: libtest.a FRC ;\
-@ echo --- e012 ---  "NULL is not a statment"  ;\
   rm -fr e012_X ;\
   mkdir e012_X ;\
   (cd e012_X ;\
     $(COMPILE) ../e012 >stdout ) 1>2 2>e012_X/stderr ;\
   diff e012/stdout e012_X/stdout ;\
   diff e012/stderr e012_X/stderr ;\
   rm -f e012_X/a.out

all:: e013_X
new_base:: e013_base
scratch:: ; -rm -fr e013_X
e013:: e013_X
e013_base:: e013_X ; @mv e013_X/stdout e013_X/stderr e013
e013_X:: libtest.a FRC ;\
-@ echo --- e013 ---  "illegal recursive declaration"  ;\
   rm -fr e013_X ;\
   mkdir e013_X ;\
   (cd e013_X ;\
     $(COMPILE) ../e013 >stdout ) 1>2 2>e013_X/stderr ;\
   diff e013/stdout e013_X/stdout ;\
   diff e013/stderr e013_X/stderr ;\
   rm -f e013_X/a.out

all:: e014_X
new_base:: e014_base
scratch:: ; -rm -fr e014_X
e014:: e014_X
e014_base:: e014_X ; @mv e014_X/stdout e014_X/stderr e014
e014_X:: libtest.a FRC ;\
-@ echo --- e014 ---  "coverage of procedure signature in interface by module"  ;\
   rm -fr e014_X ;\
   mkdir e014_X ;\
   (cd e014_X ;\
     $(COMPILE) ../e014 >stdout ) 1>2 2>e014_X/stderr ;\
   diff e014/stdout e014_X/stdout ;\
   diff e014/stderr e014_X/stderr ;\
   rm -f e014_X/a.out

all:: e015_X
new_base:: e015_base
scratch:: ; -rm -fr e015_X
e015:: e015_X
e015_base:: e015_X ; @mv e015_X/stdout e015_X/stderr e015
e015_X:: libtest.a FRC ;\
-@ echo --- e015 ---  "illegal recursive declaration x=y/y=x"  ;\
   rm -fr e015_X ;\
   mkdir e015_X ;\
   (cd e015_X ;\
     $(COMPILE) ../e015 >stdout ) 1>2 2>e015_X/stderr ;\
   diff e015/stdout e015_X/stdout ;\
   diff e015/stderr e015_X/stderr ;\
   rm -f e015_X/a.out

all:: e016_X
new_base:: e016_base
scratch:: ; -rm -fr e016_X
e016:: e016_X
e016_base:: e016_X ; @mv e016_X/stdout e016_X/stderr e016
e016_X:: libtest.a FRC ;\
-@ echo --- e016 ---  "FROM IMPORT in an EXPORTed interface is visible in the module"  ;\
   rm -fr e016_X ;\
   mkdir e016_X ;\
   (cd e016_X ;\
     $(COMPILE) ../e016 >stdout ) 1>2 2>e016_X/stderr ;\
   diff e016/stdout e016_X/stdout ;\
   diff e016/stderr e016_X/stderr ;\
   rm -f e016_X/a.out

all:: e017_X
new_base:: e017_base
scratch:: ; -rm -fr e017_X
e017:: e017_X
e017_base:: e017_X ; @mv e017_X/stdout e017_X/stderr e017
e017_X:: libtest.a FRC ;\
-@ echo --- e017 ---  "illegal recursive declaration"  ;\
   rm -fr e017_X ;\
   mkdir e017_X ;\
   (cd e017_X ;\
     $(COMPILE) ../e017 >stdout ) 1>2 2>e017_X/stderr ;\
   diff e017/stdout e017_X/stdout ;\
   diff e017/stderr e017_X/stderr ;\
   rm -f e017_X/a.out

all:: e018_X
new_base:: e018_base
scratch:: ; -rm -fr e018_X
e018:: e018_X
e018_base:: e018_X ; @mv e018_X/stdout e018_X/stderr e018
e018_X:: libtest.a FRC ;\
-@ echo --- e018 ---  "illegal recursive declaration"  ;\
   rm -fr e018_X ;\
   mkdir e018_X ;\
   (cd e018_X ;\
     $(COMPILE) ../e018 >stdout ) 1>2 2>e018_X/stderr ;\
   diff e018/stdout e018_X/stdout ;\
   diff e018/stderr e018_X/stderr ;\
   rm -f e018_X/a.out

all:: e019_X
new_base:: e019_base
scratch:: ; -rm -fr e019_X
e019:: e019_X
e019_base:: e019_X ; @mv e019_X/stdout e019_X/stderr e019
e019_X:: libtest.a FRC ;\
-@ echo --- e019 ---  "illegal recursive declaration"  ;\
   rm -fr e019_X ;\
   mkdir e019_X ;\
   (cd e019_X ;\
     $(COMPILE) ../e019 >stdout ) 1>2 2>e019_X/stderr ;\
   diff e019/stdout e019_X/stdout ;\
   diff e019/stderr e019_X/stderr ;\
   rm -f e019_X/a.out

all:: e020_X
new_base:: e020_base
scratch:: ; -rm -fr e020_X
e020:: e020_X
e020_base:: e020_X ; @mv e020_X/stdout e020_X/stderr e020
e020_X:: libtest.a FRC ;\
-@ echo --- e020 ---  "illegal recursive declaration"  ;\
   rm -fr e020_X ;\
   mkdir e020_X ;\
   (cd e020_X ;\
     $(COMPILE) ../e020 >stdout ) 1>2 2>e020_X/stderr ;\
   diff e020/stdout e020_X/stdout ;\
   diff e020/stderr e020_X/stderr ;\
   rm -f e020_X/a.out

all:: e021_X
new_base:: e021_base
scratch:: ; -rm -fr e021_X
e021:: e021_X
e021_base:: e021_X ; @mv e021_X/stdout e021_X/stderr e021
e021_X:: libtest.a FRC ;\
-@ echo --- e021 ---  "illegal recursive declaration"  ;\
   rm -fr e021_X ;\
   mkdir e021_X ;\
   (cd e021_X ;\
     $(COMPILE) ../e021 >stdout ) 1>2 2>e021_X/stderr ;\
   diff e021/stdout e021_X/stdout ;\
   diff e021/stderr e021_X/stderr ;\
   rm -f e021_X/a.out

all:: e022_X
new_base:: e022_base
scratch:: ; -rm -fr e022_X
e022:: e022_X
e022_base:: e022_X ; @mv e022_X/stdout e022_X/stderr e022
e022_X:: libtest.a FRC ;\
-@ echo --- e022 ---  "illegal recursive declaration"  ;\
   rm -fr e022_X ;\
   mkdir e022_X ;\
   (cd e022_X ;\
     $(COMPILE) ../e022 >stdout ) 1>2 2>e022_X/stderr ;\
   diff e022/stdout e022_X/stdout ;\
   diff e022/stderr e022_X/stderr ;\
   rm -f e022_X/a.out

all:: e023_X
new_base:: e023_base
scratch:: ; -rm -fr e023_X
e023:: e023_X
e023_base:: e023_X ; @mv e023_X/stdout e023_X/stderr e023
e023_X:: libtest.a FRC ;\
-@ echo --- e023 ---  "illegal recursive declaration"  ;\
   rm -fr e023_X ;\
   mkdir e023_X ;\
   (cd e023_X ;\
     $(COMPILE) ../e023 >stdout ) 1>2 2>e023_X/stderr ;\
   diff e023/stdout e023_X/stdout ;\
   diff e023/stderr e023_X/stderr ;\
   rm -f e023_X/a.out

all:: e024_X
new_base:: e024_base
scratch:: ; -rm -fr e024_X
e024:: e024_X
e024_base:: e024_X ; @mv e024_X/stdout e024_X/stderr e024
e024_X:: libtest.a FRC ;\
-@ echo --- e024 ---  "illegal recursive declaration"  ;\
   rm -fr e024_X ;\
   mkdir e024_X ;\
   (cd e024_X ;\
     $(COMPILE) ../e024 >stdout ) 1>2 2>e024_X/stderr ;\
   diff e024/stdout e024_X/stdout ;\
   diff e024/stderr e024_X/stderr ;\
   rm -f e024_X/a.out

all:: e025_X
new_base:: e025_base
scratch:: ; -rm -fr e025_X
e025:: e025_X
e025_base:: e025_X ; @mv e025_X/stdout e025_X/stderr e025
e025_X:: libtest.a FRC ;\
-@ echo --- e025 ---  "incompatible array parameter"  ;\
   rm -fr e025_X ;\
   mkdir e025_X ;\
   (cd e025_X ;\
     $(COMPILE) ../e025 >stdout ) 1>2 2>e025_X/stderr ;\
   diff e025/stdout e025_X/stdout ;\
   diff e025/stderr e025_X/stderr ;\
   rm -f e025_X/a.out

all:: e026_X
new_base:: e026_base
scratch:: ; -rm -fr e026_X
e026:: e026_X
e026_base:: e026_X ; @mv e026_X/stdout e026_X/stderr e026
e026_X:: libtest.a FRC ;\
-@ echo --- e026 ---  "two types with the same brand"  ;\
   rm -fr e026_X ;\
   mkdir e026_X ;\
   (cd e026_X ;\
     $(COMPILE) ../e026 >stdout ) 1>2 2>e026_X/stderr ;\
   diff e026/stdout e026_X/stdout ;\
   diff e026/stderr e026_X/stderr ;\
   rm -f e026_X/a.out

all:: e027_X
new_base:: e027_base
scratch:: ; -rm -fr e027_X
e027:: e027_X
e027_base:: e027_X ; @mv e027_X/stdout e027_X/stderr e027
e027_X:: libtest.a FRC ;\
-@ echo --- e027 ---  "b1tests/b005 - ARRAY [1..0] OF x is empty"  ;\
   rm -fr e027_X ;\
   mkdir e027_X ;\
   (cd e027_X ;\
     $(COMPILE) ../e027 >stdout ) 1>2 2>e027_X/stderr ;\
   diff e027/stdout e027_X/stdout ;\
   diff e027/stderr e027_X/stderr ;\
   rm -f e027_X/a.out

all:: e028_X
new_base:: e028_base
scratch:: ; -rm -fr e028_X
e028:: e028_X
e028_base:: e028_X ; @mv e028_X/stdout e028_X/stderr e028
e028_X:: libtest.a FRC ;\
-@ echo --- e028 ---  "circular FROM imports"  ;\
   rm -fr e028_X ;\
   mkdir e028_X ;\
   (cd e028_X ;\
     $(COMPILE) ../e028 >stdout ) 1>2 2>e028_X/stderr ;\
   diff e028/stdout e028_X/stdout ;\
   diff e028/stderr e028_X/stderr ;\
   rm -f e028_X/a.out

all:: e029_X
new_base:: e029_base
scratch:: ; -rm -fr e029_X
e029:: e029_X
e029_base:: e029_X ; @mv e029_X/stdout e029_X/stderr e029
e029_X:: libtest.a FRC ;\
-@ echo --- e029 ---  "use type instead of value as an initializer"  ;\
   rm -fr e029_X ;\
   mkdir e029_X ;\
   (cd e029_X ;\
     $(COMPILE) ../e029 >stdout ) 1>2 2>e029_X/stderr ;\
   diff e029/stdout e029_X/stdout ;\
   diff e029/stderr e029_X/stderr ;\
   rm -f e029_X/a.out

all:: e030_X
new_base:: e030_base
scratch:: ; -rm -fr e030_X
e030:: e030_X
e030_base:: e030_X ; @mv e030_X/stdout e030_X/stderr e030
e030_X:: libtest.a FRC ;\
-@ echo --- e030 ---  "missing main program"  ;\
   rm -fr e030_X ;\
   mkdir e030_X ;\
   (cd e030_X ;\
     $(COMPILE) ../e030 >stdout ) 1>2 2>e030_X/stderr ;\
   diff e030/stdout e030_X/stdout ;\
   diff e030/stderr e030_X/stderr ;\
   rm -f e030_X/a.out

all:: e031_X
new_base:: e031_base
scratch:: ; -rm -fr e031_X
e031:: e031_X
e031_base:: e031_X ; @mv e031_X/stdout e031_X/stderr e031
e031_X:: libtest.a FRC ;\
-@ echo --- e031 ---  "spurious '..' in array initializer"  ;\
   rm -fr e031_X ;\
   mkdir e031_X ;\
   (cd e031_X ;\
     $(COMPILE) ../e031 >stdout ) 1>2 2>e031_X/stderr ;\
   diff e031/stdout e031_X/stdout ;\
   diff e031/stderr e031_X/stderr ;\
   rm -f e031_X/a.out

all:: e032_X
new_base:: e032_base
scratch:: ; -rm -fr e032_X
e032:: e032_X
e032_base:: e032_X ; @mv e032_X/stdout e032_X/stderr e032
e032_X:: libtest.a FRC ;\
-@ echo --- e032 ---  "FROM IMPORT in an IMPORTed interface is visible in the module"  ;\
   rm -fr e032_X ;\
   mkdir e032_X ;\
   (cd e032_X ;\
     $(COMPILE) ../e032 >stdout ) 1>2 2>e032_X/stderr ;\
   diff e032/stdout e032_X/stdout ;\
   diff e032/stderr e032_X/stderr ;\
   rm -f e032_X/a.out

all:: e033_X
new_base:: e033_base
scratch:: ; -rm -fr e033_X
e033:: e033_X
e033_base:: e033_X ; @mv e033_X/stdout e033_X/stderr e033
e033_X:: libtest.a FRC ;\
-@ echo --- e033 ---  "importing the builtin scope through an arbitrary interace"  ;\
   rm -fr e033_X ;\
   mkdir e033_X ;\
   (cd e033_X ;\
     $(COMPILE) ../e033 >stdout ) 1>2 2>e033_X/stderr ;\
   diff e033/stdout e033_X/stdout ;\
   diff e033/stderr e033_X/stderr ;\
   rm -f e033_X/a.out

all:: e034_X
new_base:: e034_base
scratch:: ; -rm -fr e034_X
e034:: e034_X
e034_base:: e034_X ; @mv e034_X/stdout e034_X/stderr e034
e034_X:: libtest.a FRC ;\
-@ echo --- e034 ---  "structural equivalence of records"  ;\
   rm -fr e034_X ;\
   mkdir e034_X ;\
   (cd e034_X ;\
     $(COMPILE) ../e034 >stdout ) 1>2 2>e034_X/stderr ;\
   diff e034/stdout e034_X/stdout ;\
   diff e034/stderr e034_X/stderr ;\
   rm -f e034_X/a.out;

all:: e035_X
new_base:: e035_base
scratch:: ; -rm -fr e035_X
e035:: e035_X
e035_base:: e035_X ; @mv e035_X/stdout e035_X/stderr e035
e035_X:: libtest.a FRC ;\
-@ echo --- e035 ---  "illegal recursive declaration"  ;\
   rm -fr e035_X ;\
   mkdir e035_X ;\
   (cd e035_X ;\
     $(COMPILE) ../e035 >stdout ) 1>2 2>e035_X/stderr ;\
   diff e035/stdout e035_X/stdout ;\
   diff e035/stderr e035_X/stderr ;\
   rm -f e035_X/a.out

test:: FRC
	@echo $(PF) etests done

tidy::    ; find . -type d -print -exec m3tidy {} \;
scratch:: ; find . -type d -print -exec m3scratch {} \;
scratch:: ; /bin/rm -f .ship

create::         ; createpackage $(PACKAGE)
lock::           ; setlockpackage $(PACKAGE)
get::            ; getpackage $(PACKAGE)
unlock::         ; unlockpackage $(PACKAGE)
ship::  tidy     ; shippackage $(PACKAGE) $(EXPORT)

install:: all ship unlock

checkin::     ; vmake -noeval ; vmake -ci < /dev/null
checkout::    ; vmake -co $(PACKAGE) < /dev/null
vestacreate:: ; vmake -co $(PACKAGE).1

FRC:

