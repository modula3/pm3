This is Info file ./gdb.info, produced by Makeinfo version 1.68 from
the input file gdb.texinfo.

START-INFO-DIR-ENTRY
* Gdb: (gdb).                     The GNU debugger.
END-INFO-DIR-ENTRY
   This file documents the GNU debugger GDB.

   This is the Fifth Edition, April 1998, of `Debugging with GDB: the
GNU Source-Level Debugger' for GDB Version .

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
1997, 1998 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: gdb.info,  Node: M2 Operators,  Next: Built-In Func/Proc,  Up: Modula-2

Operators
.........

   Operators must be defined on values of specific types.  For instance,
`+' is defined on numbers, but not on structures.  Operators are often
defined on groups of types.  For the purposes of Modula-2, the
following definitions hold:

   * *Integral types* consist of `INTEGER', `CARDINAL', and their
     subranges.

   * *Character types* consist of `CHAR' and its subranges.

   * *Floating-point types* consist of `REAL'.

   * *Pointer types* consist of anything declared as `POINTER TO TYPE'.

   * *Scalar types* consist of all of the above.

   * *Set types* consist of `SET' and `BITSET' types.

   * *Boolean types* consist of `BOOLEAN'.

The following operators are supported, and appear in order of
increasing precedence:

`,'
     Function argument or array index separator.

`:='
     Assignment.  The value of VAR `:=' VALUE is VALUE.

`<, >'
     Less than, greater than on integral, floating-point, or enumerated
     types.

`<=, >='
     Less than, greater than, less than or equal to, greater than or
     equal to on integral, floating-point and enumerated types, or set
     inclusion on set types.  Same precedence as `<'.

`=, <>, #'
     Equality and two ways of expressing inequality, valid on scalar
     types.  Same precedence as `<'.  In GDB scripts, only `<>' is
     available for inequality, since `#' conflicts with the script
     comment character.

`IN'
     Set membership.  Defined on set types and the types of their
     members.  Same precedence as `<'.

`OR'
     Boolean disjunction.  Defined on boolean types.

`AND, &'
     Boolean conjuction.  Defined on boolean types.

`@'
     The GDB "artificial array" operator (*note Expressions:
     Expressions.).

`+, -'
     Addition and subtraction on integral and floating-point types, or
     union and difference on set types.

`*'
     Multiplication on integral and floating-point types, or set
     intersection on set types.

`/'
     Division on floating-point types, or symmetric set difference on
     set types.  Same precedence as `*'.

`DIV, MOD'
     Integer division and remainder.  Defined on integral types.  Same
     precedence as `*'.

`-'
     Negative. Defined on `INTEGER' and `REAL' data.

`^'
     Pointer dereferencing.  Defined on pointer types.

`NOT'
     Boolean negation.  Defined on boolean types.  Same precedence as
     `^'.

`.'
     `RECORD' field selector.  Defined on `RECORD' data.  Same
     precedence as `^'.

`[]'
     Array indexing.  Defined on `ARRAY' data.  Same precedence as `^'.

`()'
     Procedure argument list.  Defined on `PROCEDURE' objects.  Same
     precedence as `^'.

`::, .'
     GDB and Modula-2 scope operators.

     *Warning:* Sets and their operations are not yet supported, so GDB
     treats the use of the operator `IN', or the use of operators `+',
     `-', `*', `/', `=', , `<>', `#', `<=', and `>=' on sets as an
     error.


File: gdb.info,  Node: Built-In Func/Proc,  Next: M2 Constants,  Prev: M2 Operators,  Up: Modula-2

Built-in functions and procedures
.................................

   Modula-2 also makes available several built-in procedures and
functions.  In describing these, the following metavariables are used:

A
     represents an `ARRAY' variable.

C
     represents a `CHAR' constant or variable.

I
     represents a variable or constant of integral type.

M
     represents an identifier that belongs to a set.  Generally used in
     the same function with the metavariable S.  The type of S should
     be `SET OF MTYPE' (where MTYPE is the type of M).

N
     represents a variable or constant of integral or floating-point
     type.

R
     represents a variable or constant of floating-point type.

T
     represents a type.

V
     represents a variable.

X
     represents a variable or constant of one of many types.  See the
     explanation of the function for details.

   All Modula-2 built-in procedures also return a result, described
below.

`ABS(N)'
     Returns the absolute value of N.

`CAP(C)'
     If C is a lower case letter, it returns its upper case equivalent,
     otherwise it returns its argument

`CHR(I)'
     Returns the character whose ordinal value is I.

`DEC(V)'
     Decrements the value in the variable V.  Returns the new value.

`DEC(V,I)'
     Decrements the value in the variable V by I.  Returns the new
     value.

`EXCL(M,S)'
     Removes the element M from the set S.  Returns the new set.

`FLOAT(I)'
     Returns the floating point equivalent of the integer I.

`HIGH(A)'
     Returns the index of the last member of A.

`INC(V)'
     Increments the value in the variable V.  Returns the new value.

`INC(V,I)'
     Increments the value in the variable V by I.  Returns the new
     value.

`INCL(M,S)'
     Adds the element M to the set S if it is not already there.
     Returns the new set.

`MAX(T)'
     Returns the maximum value of the type T.

`MIN(T)'
     Returns the minimum value of the type T.

`ODD(I)'
     Returns boolean TRUE if I is an odd number.

`ORD(X)'
     Returns the ordinal value of its argument.  For example, the
     ordinal value of a character is its ASCII value (on machines
     supporting the ASCII character set).  X must be of an ordered
     type, which include integral, character and enumerated types.

`SIZE(X)'
     Returns the size of its argument.  X can be a variable or a type.

`TRUNC(R)'
     Returns the integral part of R.

`VAL(T,I)'
     Returns the member of the type T whose ordinal value is I.

     *Warning:*  Sets and their operations are not yet supported, so
     GDB treats the use of procedures `INCL' and `EXCL' as an error.


File: gdb.info,  Node: M2 Constants,  Next: M2 Defaults,  Prev: Built-In Func/Proc,  Up: Modula-2

Constants
.........

   GDB allows you to express the constants of Modula-2 in the following
ways:

   * Integer constants are simply a sequence of digits.  When used in an
     expression, a constant is interpreted to be type-compatible with
     the rest of the expression.  Hexadecimal integers are specified by
     a trailing `H', and octal integers by a trailing `B'.

   * Floating point constants appear as a sequence of digits, followed
     by a decimal point and another sequence of digits.  An optional
     exponent can then be specified, in the form `E[+|-]NNN', where
     `[+|-]NNN' is the desired exponent.  All of the digits of the
     floating point constant must be valid decimal (base 10) digits.

   * Character constants consist of a single character enclosed by a
     pair of like quotes, either single (`'') or double (`"').  They may
     also be expressed by their ordinal value (their ASCII value,
     usually) followed by a `C'.

   * String constants consist of a sequence of characters enclosed by a
     pair of like quotes, either single (`'') or double (`"').  Escape
     sequences in the style of C are also allowed.  *Note C and C++
     constants: C Constants, for a brief explanation of escape
     sequences.

   * Enumerated constants consist of an enumerated identifier.

   * Boolean constants consist of the identifiers `TRUE' and `FALSE'.

   * Pointer constants consist of integral values only.

   * Set constants are not yet supported.


File: gdb.info,  Node: M2 Defaults,  Next: Deviations,  Prev: M2 Constants,  Up: Modula-2

Modula-2 defaults
.................

   If type and range checking are set automatically by GDB, they both
default to `on' whenever the working language changes to Modula-2.
This happens regardless of whether you, or GDB, selected the working
language.

   If you allow GDB to set the language automatically, then entering
code compiled from a file whose name ends with `.mod' sets the working
language to Modula-2. *Note Having GDB set the language automatically:
Automatically, for further details.


File: gdb.info,  Node: Deviations,  Next: M2 Checks,  Prev: M2 Defaults,  Up: Modula-2

Deviations from standard Modula-2
.................................

   A few changes have been made to make Modula-2 programs easier to
debug.  This is done primarily via loosening its type strictness:

   * Unlike in standard Modula-2, pointer constants can be formed by
     integers.  This allows you to modify pointer variables during
     debugging.  (In standard Modula-2, the actual address contained in
     a pointer variable is hidden from you; it can only be modified
     through direct assignment to another pointer variable or
     expression that returned a pointer.)

   * C escape sequences can be used in strings and characters to
     represent non-printable characters.  GDB prints out strings with
     these escape sequences embedded.  Single non-printable characters
     are printed using the `CHR(NNN)' format.

   * The assignment operator (`:=') returns the value of its right-hand
     argument.

   * All built-in procedures both modify *and* return their argument.


File: gdb.info,  Node: M2 Checks,  Next: M2 Scope,  Prev: Deviations,  Up: Modula-2

Modula-2 type and range checks
..............................

     *Warning:* in this release, GDB does not yet perform type or range
     checking.

   GDB considers two Modula-2 variables type equivalent if:

   * They are of types that have been declared equivalent via a `TYPE
     T1 = T2' statement

   * They have been declared on the same line.  (Note:  This is true of
     the GNU Modula-2 compiler, but it may not be true of other
     compilers.)

   As long as type checking is enabled, any attempt to combine variables
whose types are not equivalent is an error.

   Range checking is done on all mathematical operations, assignment,
array index bounds, and all built-in functions and procedures.


File: gdb.info,  Node: M2 Scope,  Next: GDB/M2,  Prev: M2 Checks,  Up: Modula-2

The scope operators `::' and `.'
................................

   There are a few subtle differences between the Modula-2 scope
operator (`.') and the GDB scope operator (`::').  The two have similar
syntax:


     MODULE . ID
     SCOPE :: ID

where SCOPE is the name of a module or a procedure, MODULE the name of
a module, and ID is any declared identifier within your program, except
another module.

   Using the `::' operator makes GDB search the scope specified by
SCOPE for the identifier ID.  If it is not found in the specified
scope, then GDB searches all scopes enclosing the one specified by
SCOPE.

   Using the `.' operator makes GDB search the current scope for the
identifier specified by ID that was imported from the definition module
specified by MODULE.  With this operator, it is an error if the
identifier ID was not imported from definition module MODULE, or if ID
is not an identifier in MODULE.


File: gdb.info,  Node: GDB/M2,  Prev: M2 Scope,  Up: Modula-2

GDB and Modula-2
................

   Some GDB commands have little use when debugging Modula-2 programs.
Five subcommands of `set print' and `show print' apply specifically to
C and C++: `vtbl', `demangle', `asm-demangle', `object', and `union'.
The first four apply to C++, and the last to the C `union' type, which
has no direct analogue in Modula-2.

   The `@' operator (*note Expressions: Expressions.), while available
while using any language, is not useful with Modula-2.  Its intent is
to aid the debugging of "dynamic arrays", which cannot be created in
Modula-2 as they can in C or C++.  However, because an address can be
specified by an integral constant, the construct `{TYPE}ADREXP' is
still useful.  (*note Expressions: Expressions.)

   In GDB scripts, the Modula-2 inequality operator `#' is interpreted
as the beginning of a comment.  Use `<>' instead.


File: gdb.info,  Node: Symbols,  Next: Altering,  Prev: Languages,  Up: Top

Examining the Symbol Table
**************************

   The commands described in this section allow you to inquire about the
symbols (names of variables, functions and types) defined in your
program.  This information is inherent in the text of your program and
does not change as your program executes.  GDB finds it in your
program's symbol table, in the file indicated when you started GDB
(*note Choosing files: File Options.), or by one of the file-management
commands (*note Commands to specify files: Files.).

   Occasionally, you may need to refer to symbols that contain unusual
characters, which GDB ordinarily treats as word delimiters.  The most
frequent case is in referring to static variables in other source files
(*note Program variables: Variables.).  File names are recorded in
object files as debugging symbols, but GDB would ordinarily parse a
typical file name, like `foo.c', as the three words `foo' `.' `c'.  To
allow GDB to recognize `foo.c' as a single symbol, enclose it in single
quotes; for example,

     p 'foo.c'::x

looks up the value of `x' in the scope of the file `foo.c'.

`info address SYMBOL'
     Describe where the data for SYMBOL is stored.  For a register
     variable, this says which register it is kept in.  For a
     non-register local variable, this prints the stack-frame offset at
     which the variable is always stored.

     Note the contrast with `print &SYMBOL', which does not work at all
     for a register variable, and for a stack local variable prints the
     exact address of the current instantiation of the variable.

`whatis EXP'
     Print the data type of expression EXP.  EXP is not actually
     evaluated, and any side-effecting operations (such as assignments
     or function calls) inside it do not take place.  *Note
     Expressions: Expressions.

`whatis'
     Print the data type of `$', the last value in the value history.

`ptype TYPENAME'
     Print a description of data type TYPENAME.  TYPENAME may be the
     name of a type, or for C code it may have the form `class
     CLASS-NAME', `struct STRUCT-TAG', `union UNION-TAG' or `enum
     ENUM-TAG'.

`ptype EXP'
`ptype'
     Print a description of the type of expression EXP.  `ptype'
     differs from `whatis' by printing a detailed description, instead
     of just the name of the type.

     For example, for this variable declaration:

          struct complex {double real; double imag;} v;

     the two commands give this output:

          (gdb) whatis v
          type = struct complex
          (gdb) ptype v
          type = struct complex {
              double real;
              double imag;
          }

     As with `whatis', using `ptype' without an argument refers to the
     type of `$', the last value in the value history.

`info types REGEXP'
`info types'
     Print a brief description of all types whose name matches REGEXP
     (or all types in your program, if you supply no argument).  Each
     complete typename is matched as though it were a complete line;
     thus, `i type value' gives information on all types in your
     program whose name includes the string `value', but `i type
     ^value$' gives information only on types whose complete name is
     `value'.

     This command differs from `ptype' in two ways: first, like
     `whatis', it does not print a detailed description; second, it
     lists all source files where a type is defined.

`info source'
     Show the name of the current source file--that is, the source file
     for the function containing the current point of execution--and
     the language it was written in.

`info sources'
     Print the names of all source files in your program for which
     there is debugging information, organized into two lists: files
     whose symbols have already been read, and files whose symbols will
     be read when needed.

`info functions'
     Print the names and data types of all defined functions.

`info functions REGEXP'
     Print the names and data types of all defined functions whose
     names contain a match for regular expression REGEXP.  Thus, `info
     fun step' finds all functions whose names include `step'; `info
     fun ^step' finds those whose names start with `step'.

`info variables'
     Print the names and data types of all variables that are declared
     outside of functions (i.e., excluding local variables).

`info variables REGEXP'
     Print the names and data types of all variables (except for local
     variables) whose names contain a match for regular expression
     REGEXP.

     Some systems allow individual object files that make up your
     program to be replaced without stopping and restarting your
     program.  For example, in VxWorks you can simply recompile a
     defective object file and keep on running.  If you are running on
     one of these systems, you can allow GDB to reload the symbols for
     automatically relinked modules:

    `set symbol-reloading on'
          Replace symbol definitions for the corresponding source file
          when an object file with a particular name is seen again.

    `set symbol-reloading off'
          Do not replace symbol definitions when re-encountering object
          files of the same name.  This is the default state; if you
          are not running on a system that permits automatically
          relinking modules, you should leave `symbol-reloading' off,
          since otherwise GDB may discard symbols when linking large
          programs, that may contain several modules (from different
          directories or libraries) with the same name.

    `show symbol-reloading'
          Show the current `on' or `off' setting.

`maint print symbols FILENAME'
`maint print psymbols FILENAME'
`maint print msymbols FILENAME'
     Write a dump of debugging symbol data into the file FILENAME.
     These commands are used to debug the GDB symbol-reading code.  Only
     symbols with debugging data are included.  If you use `maint print
     symbols', GDB includes all the symbols for which it has already
     collected full details: that is, FILENAME reflects symbols for
     only those files whose symbols GDB has read.  You can use the
     command `info sources' to find out which files these are.  If you
     use `maint print psymbols' instead, the dump shows information
     about symbols that GDB only knows partially--that is, symbols
     defined in files that GDB has skimmed, but not yet read
     completely.  Finally, `maint print msymbols' dumps just the
     minimal symbol information required for each object file from
     which GDB has read some symbols.  *Note Commands to specify files:
     Files, for a discussion of how GDB reads symbols (in the
     description of `symbol-file').


File: gdb.info,  Node: Altering,  Next: GDB Files,  Prev: Symbols,  Up: Top

Altering Execution
******************

   Once you think you have found an error in your program, you might
want to find out for certain whether correcting the apparent error
would lead to correct results in the rest of the run.  You can find the
answer by experiment, using the GDB features for altering execution of
the program.

   For example, you can store new values into variables or memory
locations, give your program a signal, restart it at a different
address, or even return prematurely from a function.

* Menu:

* Assignment::                  Assignment to variables
* Jumping::                     Continuing at a different address

* Signaling::                   Giving your program a signal

* Returning::                   Returning from a function
* Calling::                     Calling your program's functions
* Patching::                    Patching your program


File: gdb.info,  Node: Assignment,  Next: Jumping,  Up: Altering

Assignment to variables
=======================

   To alter the value of a variable, evaluate an assignment expression.
*Note Expressions: Expressions.  For example,

     print x=4

stores the value 4 into the variable `x', and then prints the value of
the assignment expression (which is 4).  *Note Using GDB with Different
Languages: Languages, for more information on operators in supported
languages.

   If you are not interested in seeing the value of the assignment, use
the `set' command instead of the `print' command.  `set' is really the
same as `print' except that the expression's value is not printed and
is not put in the value history (*note Value history: Value History.).
The expression is evaluated only for its effects.

   If the beginning of the argument string of the `set' command appears
identical to a `set' subcommand, use the `set variable' command instead
of just `set'.  This command is identical to `set' except for its lack
of subcommands.  For example, if your program has a variable `width',
you get an error if you try to set a new value with just `set width=13',
because GDB has the command `set width':

     (gdb) whatis width
     type = double
     (gdb) p width
     $4 = 13
     (gdb) set width=47
     Invalid syntax in expression.

The invalid expression, of course, is `=47'.  In order to actually set
the program's variable `width', use

     (gdb) set var width=47

   GDB allows more implicit conversions in assignments than C; you can
freely store an integer value into a pointer variable or vice versa,
and you can convert any structure to any other structure that is the
same length or shorter.

   To store values into arbitrary places in memory, use the `{...}'
construct to generate a value of specified type at a specified address
(*note Expressions: Expressions.).  For example, `{int}0x83040' refers
to memory location `0x83040' as an integer (which implies a certain size
and representation in memory), and

     set {int}0x83040 = 4

stores the value 4 into that memory location.


File: gdb.info,  Node: Jumping,  Next: Signaling,  Prev: Assignment,  Up: Altering

Continuing at a different address
=================================

   Ordinarily, when you continue your program, you do so at the place
where it stopped, with the `continue' command.  You can instead
continue at an address of your own choosing, with the following
commands:

`jump LINESPEC'
     Resume execution at line LINESPEC.  Execution stops again
     immediately if there is a breakpoint there.  *Note Printing source
     lines: List, for a description of the different forms of LINESPEC.

     The `jump' command does not change the current stack frame, or the
     stack pointer, or the contents of any memory location or any
     register other than the program counter.  If line LINESPEC is in a
     different function from the one currently executing, the results
     may be bizarre if the two functions expect different patterns of
     arguments or of local variables.  For this reason, the `jump'
     command requests confirmation if the specified line is not in the
     function currently executing.  However, even bizarre results are
     predictable if you are well acquainted with the machine-language
     code of your program.

`jump *ADDRESS'
     Resume execution at the instruction at address ADDRESS.

   You can get much the same effect as the `jump' command by storing a
new value into the register `$pc'.  The difference is that this does
not start your program running; it only changes the address of where it
*will* run when you continue.  For example,

     set $pc = 0x485

makes the next `continue' command or stepping command execute at
address `0x485', rather than at the address where your program stopped.
*Note Continuing and stepping: Continuing and Stepping.

   The most common occasion to use the `jump' command is to back up-
perhaps with more breakpoints set-over a portion of a program that has
already executed, in order to examine its execution in more detail.


File: gdb.info,  Node: Signaling,  Next: Returning,  Prev: Jumping,  Up: Altering

Giving your program a signal
============================

`signal SIGNAL'
     Resume execution where your program stopped, but immediately give
     it the signal SIGNAL.  SIGNAL can be the name or the number of a
     signal.  For example, on many systems `signal 2' and `signal
     SIGINT' are both ways of sending an interrupt signal.

     Alternatively, if SIGNAL is zero, continue execution without
     giving a signal.  This is useful when your program stopped on
     account of a signal and would ordinary see the signal when resumed
     with the `continue' command; `signal 0' causes it to resume
     without a signal.

     `signal' does not repeat when you press <RET> a second time after
     executing the command.

   Invoking the `signal' command is not the same as invoking the `kill'
utility from the shell.  Sending a signal with `kill' causes GDB to
decide what to do with the signal depending on the signal handling
tables (*note Signals::.).  The `signal' command passes the signal
directly to your program.


File: gdb.info,  Node: Returning,  Next: Calling,  Prev: Signaling,  Up: Altering

Returning from a function
=========================

`return'
`return EXPRESSION'
     You can cancel execution of a function call with the `return'
     command.  If you give an EXPRESSION argument, its value is used as
     the function's return value.

   When you use `return', GDB discards the selected stack frame (and
all frames within it).  You can think of this as making the discarded
frame return prematurely.  If you wish to specify a value to be
returned, give that value as the argument to `return'.

   This pops the selected stack frame (*note Selecting a frame:
Selection.), and any other frames inside of it, leaving its caller as
the innermost remaining frame.  That frame becomes selected.  The
specified value is stored in the registers used for returning values of
functions.

   The `return' command does not resume execution; it leaves the
program stopped in the state that would exist if the function had just
returned.  In contrast, the `finish' command (*note Continuing and
stepping: Continuing and Stepping.) resumes execution until the
selected stack frame returns naturally.


File: gdb.info,  Node: Calling,  Next: Patching,  Prev: Returning,  Up: Altering

Calling program functions
=========================

`call EXPR'
     Evaluate the expression EXPR without displaying `void' returned
     values.

   You can use this variant of the `print' command if you want to
execute a function from your program, but without cluttering the output
with `void' returned values.  If the result is not void, it is printed
and saved in the value history.

   A new user-controlled variable, CALL_SCRATCH_ADDRESS, specifies the
location of a scratch area to be used when GDB calls a function in the
target.  This is necessary because the usual method of putting the
scratch area on the stack does not work in systems that have separate
instruction and data spaces.


File: gdb.info,  Node: Patching,  Prev: Calling,  Up: Altering

Patching programs
=================

   By default, GDB opens the file containing your program's executable
code (or the corefile) read-only.  This prevents accidental alterations
to machine code; but it also prevents you from intentionally patching
your program's binary.

   If you'd like to be able to patch the binary, you can specify that
explicitly with the `set write' command.  For example, you might want
to turn on internal debugging flags, or even to make emergency repairs.

`set write on'
`set write off'
     If you specify `set write on', GDB opens executable and core files
     for both reading and writing; if you specify `set write off' (the
     default), GDB opens them read-only.

     If you have already loaded a file, you must load it again (using
     the `exec-file' or `core-file' command) after changing `set
     write', for your new setting to take effect.

`show write'
     Display whether executable files and core files are opened for
     writing as well as reading.


File: gdb.info,  Node: GDB Files,  Next: Targets,  Prev: Altering,  Up: Top

GDB Files
*********

   GDB needs to know the file name of the program to be debugged, both
in order to read its symbol table and in order to start your program.
To debug a core dump of a previous run, you must also tell GDB the name
of the core dump file.

* Menu:

* Files::                       Commands to specify files
* Symbol Errors::               Errors reading symbol files


File: gdb.info,  Node: Files,  Next: Symbol Errors,  Up: GDB Files

Commands to specify files
=========================

   You may want to specify executable and core dump file names.  The
usual way to do this is at start-up time, using the arguments to GDB's
start-up commands (*note Getting In and Out of GDB: Invocation.).

   Occasionally it is necessary to change to a different file during a
GDB session.  Or you may run GDB and forget to specify a file you want
to use.  In these situations the GDB commands to specify new files are
useful.

`file FILENAME'
     Use FILENAME as the program to be debugged.  It is read for its
     symbols and for the contents of pure memory.  It is also the
     program executed when you use the `run' command.  If you do not
     specify a directory and the file is not found in the GDB working
     directory, GDB uses the environment variable `PATH' as a list of
     directories to search, just as the shell does when looking for a
     program to run.  You can change the value of this variable, for
     both GDB and your program, using the `path' command.

     On systems with memory-mapped files, an auxiliary file
     `FILENAME.syms' may hold symbol table information for FILENAME.
     If so, GDB maps in the symbol table from `FILENAME.syms', starting
     up more quickly.  See the descriptions of the file options
     `-mapped' and `-readnow' (available on the command line, and with
     the commands `file', `symbol-file', or `add-symbol-file',
     described below), for more information.

`file'
     `file' with no argument makes GDB discard any information it has
     on both executable file and the symbol table.

`exec-file [ FILENAME ]'
     Specify that the program to be run (but not the symbol table) is
     found in FILENAME.  GDB searches the environment variable `PATH'
     if necessary to locate your program.  Omitting FILENAME means to
     discard information on the executable file.

`symbol-file [ FILENAME ]'
     Read symbol table information from file FILENAME.  `PATH' is
     searched when necessary.  Use the `file' command to get both symbol
     table and program to run from the same file.

     `symbol-file' with no argument clears out GDB information on your
     program's symbol table.

     The `symbol-file' command causes GDB to forget the contents of its
     convenience variables, the value history, and all breakpoints and
     auto-display expressions.  This is because they may contain
     pointers to the internal data recording symbols and data types,
     which are part of the old symbol table data being discarded inside
     GDB.

     `symbol-file' does not repeat if you press <RET> again after
     executing it once.

     When GDB is configured for a particular environment, it
     understands debugging information in whatever format is the
     standard generated for that environment; you may use either a GNU
     compiler, or other compilers that adhere to the local conventions.
     Best results are usually obtained from GNU compilers; for
     example, using `gcc' you can generate debugging information for
     optimized code.

     On some kinds of object files, the `symbol-file' command does not
     normally read the symbol table in full right away.  Instead, it
     scans the symbol table quickly to find which source files and
     which symbols are present.  The details are read later, one source
     file at a time, as they are needed.

     The purpose of this two-stage reading strategy is to make GDB
     start up faster.  For the most part, it is invisible except for
     occasional pauses while the symbol table details for a particular
     source file are being read.  (The `set verbose' command can turn
     these pauses into messages if desired.  *Note Optional warnings
     and messages: Messages/Warnings.)

     We have not implemented the two-stage strategy for COFF yet.  When
     the symbol table is stored in COFF format, `symbol-file' reads the
     symbol table data in full right away.

`symbol-file FILENAME [ -readnow ] [ -mapped ]'
`file FILENAME [ -readnow ] [ -mapped ]'
     You can override the GDB two-stage strategy for reading symbol
     tables by using the `-readnow' option with any of the commands that
     load symbol table information, if you want to be sure GDB has the
     entire symbol table available.

     If memory-mapped files are available on your system through the
     `mmap' system call, you can use another option, `-mapped', to
     cause GDB to write the symbols for your program into a reusable
     file.  Future GDB debugging sessions map in symbol information
     from this auxiliary symbol file (if the program has not changed),
     rather than spending time reading the symbol table from the
     executable program.  Using the `-mapped' option has the same
     effect as starting GDB with the `-mapped' command-line option.

     You can use both options together, to make sure the auxiliary
     symbol file has all the symbol information for your program.

     The auxiliary symbol file for a program called MYPROG is called
     `MYPROG.syms'.  Once this file exists (so long as it is newer than
     the corresponding executable), GDB always attempts to use it when
     you debug MYPROG; no special options or commands are needed.

     The `.syms' file is specific to the host machine where you run
     GDB.  It holds an exact image of the internal GDB symbol table.
     It cannot be shared across multiple host platforms.

`core-file [ FILENAME ]'
     Specify the whereabouts of a core dump file to be used as the
     "contents of memory".  Traditionally, core files contain only some
     parts of the address space of the process that generated them; GDB
     can access the executable file itself for other parts.

     `core-file' with no argument specifies that no core file is to be
     used.

     Note that the core file is ignored when your program is actually
     running under GDB.  So, if you have been running your program and
     you wish to debug a core file instead, you must kill the
     subprocess in which the program is running.  To do this, use the
     `kill' command (*note Killing the child process: Kill Process.).

`load FILENAME'
     Depending on what remote debugging facilities are configured into
     GDB, the `load' command may be available.  Where it exists, it is
     meant to make FILENAME (an executable) available for debugging on
     the remote system--by downloading, or dynamic linking, for example.
     `load' also records the FILENAME symbol table in GDB, like the
     `add-symbol-file' command.

     If your GDB does not have a `load' command, attempting to execute
     it gets the error message "`You can't do that when your target is
     ...'"

     The file is loaded at whatever address is specified in the
     executable.  For some object file formats, you can specify the
     load address when you link the program; for other formats, like
     a.out, the object file format specifies a fixed address.

     On VxWorks, `load' links FILENAME dynamically on the current
     target system as well as adding its symbols in GDB.

     With the Nindy interface to an Intel 960 board, `load' downloads
     FILENAME to the 960 as well as adding its symbols in GDB.

     When you select remote debugging to a Hitachi SH, H8/300, or
     H8/500 board (*note GDB and Hitachi Microprocessors: Hitachi
     Remote.), the `load' command downloads your program to the Hitachi
     board and also opens it as the current executable target for GDB
     on your host (like the `file' command).

     `load' does not repeat if you press <RET> again after using it.

`add-symbol-file FILENAME ADDRESS'
`add-symbol-file FILENAME ADDRESS [ -readnow ] [ -mapped ]'
     The `add-symbol-file' command reads additional symbol table
     information from the file FILENAME.  You would use this command
     when FILENAME has been dynamically loaded (by some other means)
     into the program that is running.  ADDRESS should be the memory
     address at which the file has been loaded; GDB cannot figure this
     out for itself.  You can specify ADDRESS as an expression.

     The symbol table of the file FILENAME is added to the symbol table
     originally read with the `symbol-file' command.  You can use the
     `add-symbol-file' command any number of times; the new symbol data
     thus read keeps adding to the old.  To discard all old symbol data
     instead, use the `symbol-file' command.

     `add-symbol-file' does not repeat if you press <RET> after using
     it.

     You can use the `-mapped' and `-readnow' options just as with the
     `symbol-file' command, to change how GDB manages the symbol table
     information for FILENAME.

`add-shared-symbol-file'
     The `add-shared-symbol-file' command can be used only under
     Harris' CXUX operating system for the Motorola 88k.  GDB
     automatically looks for shared libraries, however if GDB does not
     find yours, you can run `add-shared-symbol-file'.  It takes no
     arguments.

`section'
     The `section' command changes the base address of section SECTION
     of the exec file to ADDR.  This can be used if the exec file does
     not contain section addresses, (such as in the a.out format), or
     when the addresses specified in the file itself are wrong.  Each
     section must be changed separately.  The "info files" command
     lists all the sections and their addresses.

`info files'
`info target'
     `info files' and `info target' are synonymous; both print the
     current target (*note Specifying a Debugging Target: Targets.),
     including the names of the executable and core dump files
     currently in use by GDB, and the files from which symbols were
     loaded.  The command `help target' lists all possible targets
     rather than current ones.

   All file-specifying commands allow both absolute and relative file
names as arguments.  GDB always converts the file name to an absolute
file name and remembers it that way.

   GDB supports SunOS, SVr4, Irix 5, and IBM RS/6000 shared libraries.
GDB automatically loads symbol definitions from shared libraries when
you use the `run' command, or when you examine a core file.  (Before
you issue the `run' command, GDB does not understand references to a
function in a shared library, however--unless you are debugging a core
file).

`info share'
`info sharedlibrary'
     Print the names of the shared libraries which are currently loaded.

`sharedlibrary REGEX'
`share REGEX'
     Load shared object library symbols for files matching a Unix
     regular expression.  As with files loaded automatically, it only
     loads shared libraries required by your program for a core file or
     after typing `run'.  If REGEX is omitted all shared libraries
     required by your program are loaded.


File: gdb.info,  Node: Symbol Errors,  Prev: Files,  Up: GDB Files

Errors reading symbol files
===========================

   While reading a symbol file, GDB occasionally encounters problems,
such as symbol types it does not recognize, or known bugs in compiler
output.  By default, GDB does not notify you of such problems, since
they are relatively common and primarily of interest to people
debugging compilers.  If you are interested in seeing information about
ill-constructed symbol tables, you can either ask GDB to print only one
message about each such type of problem, no matter how many times the
problem occurs; or you can ask GDB to print more messages, to see how
many times the problems occur, with the `set complaints' command (*note
Optional warnings and messages: Messages/Warnings.).

   The messages currently printed, and their meanings, include:

`inner block not inside outer block in SYMBOL'
     The symbol information shows where symbol scopes begin and end
     (such as at the start of a function or a block of statements).
     This error indicates that an inner scope block is not fully
     contained in its outer scope blocks.

     GDB circumvents the problem by treating the inner block as if it
     had the same scope as the outer block.  In the error message,
     SYMBOL may be shown as "`(don't know)'" if the outer block is not a
     function.

`block at ADDRESS out of order'
     The symbol information for symbol scope blocks should occur in
     order of increasing addresses.  This error indicates that it does
     not do so.

     GDB does not circumvent this problem, and has trouble locating
     symbols in the source file whose symbols it is reading.  (You can
     often determine what source file is affected by specifying `set
     verbose on'.  *Note Optional warnings and messages:
     Messages/Warnings.)

`bad block start address patched'
     The symbol information for a symbol scope block has a start address
     smaller than the address of the preceding source line.  This is
     known to occur in the SunOS 4.1.1 (and earlier) C compiler.

     GDB circumvents the problem by treating the symbol scope block as
     starting on the previous source line.

`bad string table offset in symbol N'
     Symbol number N contains a pointer into the string table which is
     larger than the size of the string table.

     GDB circumvents the problem by considering the symbol to have the
     name `foo', which may cause other problems if many symbols end up
     with this name.

`unknown symbol type `0xNN''
     The symbol information contains new data types that GDB does not
     yet know how to read.  `0xNN' is the symbol type of the
     misunderstood information, in hexadecimal.

     GDB circumvents the error by ignoring this symbol information.
     This usually allows you to debug your program, though certain
     symbols are not accessible.  If you encounter such a problem and
     feel like debugging it, you can debug `gdb' with itself,
     breakpoint on `complain', then go up to the function
     `read_dbx_symtab' and examine `*bufp' to see the symbol.

`stub type has NULL name'
     GDB could not find the full definition for a struct or class.

`const/volatile indicator missing (ok if using g++ v1.x), got...'
     The symbol information for a C++ member function is missing some
     information that recent versions of the compiler should have output
     for it.

`info mismatch between compiler and debugger'
     GDB could not parse a type specification output by the compiler.


File: gdb.info,  Node: Targets,  Next: Controlling GDB,  Prev: GDB Files,  Up: Top

Specifying a Debugging Target
*****************************

   A "target" is the execution environment occupied by your program.
Often, GDB runs in the same host environment as your program; in that
case, the debugging target is specified as a side effect when you use
the `file' or `core' commands.  When you need more flexibility--for
example, running GDB on a physically separate host, or controlling a
standalone system over a serial port or a realtime system over a TCP/IP
connection--you can use the `target' command to specify one of the
target types configured for GDB (*note Commands for managing targets:
Target Commands.).

* Menu:

* Active Targets::              Active targets
* Target Commands::             Commands for managing targets
* Remote::                      Remote debugging


File: gdb.info,  Node: Active Targets,  Next: Target Commands,  Up: Targets

Active targets
==============

   There are three classes of targets: processes, core files, and
executable files.  GDB can work concurrently on up to three active
targets, one in each class.  This allows you to (for example) start a
process and inspect its activity without abandoning your work on a core
file.

   For example, if you execute `gdb a.out', then the executable file
`a.out' is the only active target.  If you designate a core file as
well--presumably from a prior run that crashed and coredumped--then GDB
has two active targets and uses them in tandem, looking first in the
corefile target, then in the executable file, to satisfy requests for
memory addresses.  (Typically, these two classes of target are
complementary, since core files contain only a program's read-write
memory--variables and so on--plus machine status, while executable
files contain only the program text and initialized data.)

   When you type `run', your executable file becomes an active process
target as well.  When a process target is active, all GDB commands
requesting memory addresses refer to that target; addresses in an
active core file or executable file target are obscured while the
process target is active.

   Use the `core-file' and `exec-file' commands to select a new core
file or executable target (*note Commands to specify files: Files.).
To specify as a target a process that is already running, use the
`attach' command (*note Debugging an already-running process: Attach.).

