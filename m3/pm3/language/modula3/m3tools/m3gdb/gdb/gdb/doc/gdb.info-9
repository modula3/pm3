This is ./gdb.info, produced by makeinfo version 4.0b from gdb.texinfo.

INFO-DIR-SECTION Programming & development tools.
START-INFO-DIR-ENTRY
* Gdb: (gdb).                     The GNU debugger.
END-INFO-DIR-ENTRY

   This file documents the GNU debugger GDB.

   This is the Ninth Edition, December 2001, of `Debugging with GDB:
the GNU Source-Level Debugger' for GDB Version 5.1.0.1.

   Copyright (C)
1988,1989,1990,1991,1992,1993,1994,1995,1996,1998,1999,2000,2001
Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software" and "Free Software Needs Free
Documentation", with the Front-Cover Texts being "A GNU Manual," and
with the Back-Cover Texts as in (a) below.

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: gdb.info,  Node: VxWorks,  Up: Embedded OS

Using GDB with VxWorks
----------------------

`target vxworks MACHINENAME'
     A VxWorks system, attached via TCP/IP.  The argument MACHINENAME
     is the target system's machine name or IP address.

   On VxWorks, `load' links FILENAME dynamically on the current target
system as well as adding its symbols in GDB.

   GDB enables developers to spawn and debug tasks running on networked
VxWorks targets from a Unix host.  Already-running tasks spawned from
the VxWorks shell can also be debugged.  GDB uses code that runs on
both the Unix host and on the VxWorks target.  The program `gdb' is
installed and executed on the Unix host.  (It may be installed with the
name `vxgdb', to distinguish it from a GDB for debugging programs on
the host itself.)

`VxWorks-timeout ARGS'
     All VxWorks-based targets now support the option `vxworks-timeout'.
     This option is set by the user, and  ARGS represents the number of
     seconds GDB waits for responses to rpc's.  You might use this if
     your VxWorks target is a slow software simulator or is on the far
     side of a thin network line.

   The following information on connecting to VxWorks was current when
this manual was produced; newer releases of VxWorks may use revised
procedures.

   To use GDB with VxWorks, you must rebuild your VxWorks kernel to
include the remote debugging interface routines in the VxWorks library
`rdb.a'.  To do this, define `INCLUDE_RDB' in the VxWorks configuration
file `configAll.h' and rebuild your VxWorks kernel.  The resulting
kernel contains `rdb.a', and spawns the source debugging task
`tRdbTask' when VxWorks is booted.  For more information on configuring
and remaking VxWorks, see the manufacturer's manual.

   Once you have included `rdb.a' in your VxWorks system image and set
your Unix execution search path to find GDB, you are ready to run GDB.
From your Unix host, run `gdb' (or `vxgdb', depending on your
installation).

   GDB comes up showing the prompt:

     (vxgdb)

* Menu:

* VxWorks Connection::          Connecting to VxWorks
* VxWorks Download::            VxWorks download
* VxWorks Attach::              Running tasks


File: gdb.info,  Node: VxWorks Connection,  Next: VxWorks Download,  Up: VxWorks

Connecting to VxWorks
.....................

   The GDB command `target' lets you connect to a VxWorks target on the
network.  To connect to a target whose host name is "`tt'", type:

     (vxgdb) target vxworks tt

   GDB displays messages like these:

     Attaching remote machine across net...
     Connected to tt.

   GDB then attempts to read the symbol tables of any object modules
loaded into the VxWorks target since it was last booted.  GDB locates
these files by searching the directories listed in the command search
path (*note Your program's environment: Environment.); if it fails to
find an object file, it displays a message such as:

     prog.o: No such file or directory.

   When this happens, add the appropriate directory to the search path
with the GDB command `path', and execute the `target' command again.


File: gdb.info,  Node: VxWorks Download,  Next: VxWorks Attach,  Prev: VxWorks Connection,  Up: VxWorks

VxWorks download
................

   If you have connected to the VxWorks target and you want to debug an
object that has not yet been loaded, you can use the GDB `load' command
to download a file from Unix to VxWorks incrementally.  The object file
given as an argument to the `load' command is actually opened twice:
first by the VxWorks target in order to download the code, then by GDB
in order to read the symbol table.  This can lead to problems if the
current working directories on the two systems differ.  If both systems
have NFS mounted the same filesystems, you can avoid these problems by
using absolute paths.  Otherwise, it is simplest to set the working
directory on both systems to the directory in which the object file
resides, and then to reference the file by its name, without any path.
For instance, a program `prog.o' may reside in `VXPATH/vw/demo/rdb' in
VxWorks and in `HOSTPATH/vw/demo/rdb' on the host.  To load this
program, type this on VxWorks:

     -> cd "VXPATH/vw/demo/rdb"

Then, in GDB, type:

     (vxgdb) cd HOSTPATH/vw/demo/rdb
     (vxgdb) load prog.o

   GDB displays a response similar to this:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   You can also use the `load' command to reload an object module after
editing and recompiling the corresponding source file.  Note that this
makes GDB delete all currently-defined breakpoints, auto-displays, and
convenience variables, and to clear the value history.  (This is
necessary in order to preserve the integrity of debugger's data
structures that reference the target system's symbol table.)


File: gdb.info,  Node: VxWorks Attach,  Prev: VxWorks Download,  Up: VxWorks

Running tasks
.............

   You can also attach to an existing task using the `attach' command as
follows:

     (vxgdb) attach TASK

where TASK is the VxWorks hexadecimal task ID.  The task can be running
or suspended when you attach to it.  Running tasks are suspended at the
time of attachment.


File: gdb.info,  Node: Embedded Processors,  Next: Architectures,  Prev: Embedded OS,  Up: Configurations

Embedded Processors
===================

   This section goes into details specific to particular embedded
configurations.

* Menu:

* A29K Embedded::               AMD A29K Embedded
* ARM::                         ARM
* H8/300::                      Hitachi H8/300
* H8/500::                      Hitachi H8/500
* i960::                        Intel i960
* M32R/D::                      Mitsubishi M32R/D
* M68K::                        Motorola M68K
* M88K::                        Motorola M88K
* MIPS Embedded::               MIPS Embedded
* PA::                          HP PA Embedded
* PowerPC:                      PowerPC
* SH::                          Hitachi SH
* Sparclet::                    Tsqware Sparclet
* Sparclite::                   Fujitsu Sparclite
* ST2000::                      Tandem ST2000
* Z8000::                       Zilog Z8000


File: gdb.info,  Node: A29K Embedded,  Next: ARM,  Up: Embedded Processors

AMD A29K Embedded
-----------------

* Menu:

* A29K UDI::
* A29K EB29K::
* Comms (EB29K)::               Communications setup
* gdb-EB29K::                   EB29K cross-debugging
* Remote Log::                  Remote log

`target adapt DEV'
     Adapt monitor for A29K.

`target amd-eb DEV SPEED PROG'
     Remote PC-resident AMD EB29K board, attached over serial lines.
     DEV is the serial device, as for `target remote'; SPEED allows you
     to specify the linespeed; and PROG is the name of the program to
     be debugged, as it appears to DOS on the PC.  *Note EBMON protocol
     for AMD29K: A29K EB29K.


File: gdb.info,  Node: A29K UDI,  Next: A29K EB29K,  Up: A29K Embedded

A29K UDI
........

   GDB supports AMD's UDI ("Universal Debugger Interface") protocol for
debugging the a29k processor family.  To use this configuration with
AMD targets running the MiniMON monitor, you need the program `MONTIP',
available from AMD at no charge.  You can also use GDB with the
UDI-conformant a29k simulator program `ISSTIP', also available from AMD.

`target udi KEYWORD'
     Select the UDI interface to a remote a29k board or simulator, where
     KEYWORD is an entry in the AMD configuration file `udi_soc'.  This
     file contains keyword entries which specify parameters used to
     connect to a29k targets.  If the `udi_soc' file is not in your
     working directory, you must set the environment variable `UDICONF'
     to its pathname.


File: gdb.info,  Node: A29K EB29K,  Next: Comms (EB29K),  Prev: A29K UDI,  Up: A29K Embedded

EBMON protocol for AMD29K
.........................

   AMD distributes a 29K development board meant to fit in a PC,
together with a DOS-hosted monitor program called `EBMON'.  As a
shorthand term, this development system is called the "EB29K".  To use
GDB from a Unix system to run programs on the EB29K board, you must
first connect a serial cable between the PC (which hosts the EB29K
board) and a serial port on the Unix system.  In the following, we
assume you've hooked the cable between the PC's `COM1' port and
`/dev/ttya' on the Unix system.


File: gdb.info,  Node: Comms (EB29K),  Next: gdb-EB29K,  Prev: A29K EB29K,  Up: A29K Embedded

Communications setup
....................

   The next step is to set up the PC's port, by doing something like
this in DOS on the PC:

     C:\> MODE com1:9600,n,8,1,none

This example--run on an MS DOS 4.0 system--sets the PC port to 9600
bps, no parity, eight data bits, one stop bit, and no "retry" action;
you must match the communications parameters when establishing the Unix
end of the connection as well.

   To give control of the PC to the Unix side of the serial line, type
the following at the DOS console:

     C:\> CTTY com1

(Later, if you wish to return control to the DOS console, you can use
the command `CTTY con'--but you must send it over the device that had
control, in our example over the `COM1' serial line.)

   From the Unix host, use a communications program such as `tip' or
`cu' to communicate with the PC; for example,

     cu -s 9600 -l /dev/ttya

The `cu' options shown specify, respectively, the linespeed and the
serial port to use.  If you use `tip' instead, your command line may
look something like the following:

     tip -9600 /dev/ttya

Your system may require a different name where we show `/dev/ttya' as
the argument to `tip'.  The communications parameters, including which
port to use, are associated with the `tip' argument in the "remote"
descriptions file--normally the system table `/etc/remote'.

   Using the `tip' or `cu' connection, change the DOS working directory
to the directory containing a copy of your 29K program, then start the
PC program `EBMON' (an EB29K control program supplied with your board
by AMD).  You should see an initial display from `EBMON' similar to the
one that follows, ending with the `EBMON' prompt `#'--

     C:\> G:
     
     G:\> CD \usr\joe\work29k
     
     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.
     
     Enter '?' or 'H' for help
     
     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000
     
     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff
     
     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800
     
     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes
     
     # ~.

   Then exit the `cu' or `tip' program (done in the example by typing
`~.' at the `EBMON' prompt).  `EBMON' keeps running, ready for GDB to
take over.

   For this example, we've assumed what is probably the most convenient
way to make sure the same 29K program is on both the PC and the Unix
system: a PC/NFS connection that establishes "drive `G:'" on the PC as
a file system on the Unix host.  If you do not have PC/NFS or something
similar connecting the two systems, you must arrange some other
way--perhaps floppy-disk transfer--of getting the 29K program from the
Unix system to the PC; GDB does _not_ download it over the serial line.


File: gdb.info,  Node: gdb-EB29K,  Next: Remote Log,  Prev: Comms (EB29K),  Up: A29K Embedded

EB29K cross-debugging
.....................

   Finally, `cd' to the directory containing an image of your 29K
program on the Unix system, and start GDB--specifying as argument the
name of your 29K program:

     cd /usr/joe/work29k
     gdb myfoo

   Now you can use the `target' command:

     target amd-eb /dev/ttya 9600 MYFOO

In this example, we've assumed your program is in a file called
`myfoo'.  Note that the filename given as the last argument to `target
amd-eb' should be the name of the program as it appears to DOS.  In our
example this is simply `MYFOO', but in general it can include a DOS
path, and depending on your transfer mechanism may not resemble the
name on the Unix side.

   At this point, you can set any breakpoints you wish; when you are
ready to see your program run on the 29K board, use the GDB command
`run'.

   To stop debugging the remote program, use the GDB `detach' command.

   To return control of the PC to its console, use `tip' or `cu' once
again, after your GDB session has concluded, to attach to `EBMON'.  You
can then type the command `q' to shut down `EBMON', returning control
to the DOS command-line interpreter.  Type `CTTY con' to return command
input to the main DOS console, and type `~.' to leave `tip' or `cu'.


File: gdb.info,  Node: Remote Log,  Prev: gdb-EB29K,  Up: A29K Embedded

Remote log
..........

   The `target amd-eb' command creates a file `eb.log' in the current
working directory, to help debug problems with the connection.
`eb.log' records all the output from `EBMON', including echoes of the
commands sent to it.  Running `tail -f' on this file in another window
often helps to understand trouble with `EBMON', or unexpected events on
the PC side of the connection.


File: gdb.info,  Node: ARM,  Next: H8/300,  Prev: A29K Embedded,  Up: Embedded Processors

ARM
---

`target rdi DEV'
     ARM Angel monitor, via RDI library interface to ADP protocol.  You
     may use this target to communicate with both boards running the
     Angel monitor, or with the EmbeddedICE JTAG debug device.

`target rdp DEV'
     ARM Demon monitor.


File: gdb.info,  Node: H8/300,  Next: H8/500,  Prev: ARM,  Up: Embedded Processors

Hitachi H8/300
--------------

`target hms DEV'
     A Hitachi SH, H8/300, or H8/500 board, attached via serial line to
     your host.  Use special commands `device' and `speed' to control
     the serial line and the communications speed used.

`target e7000 DEV'
     E7000 emulator for Hitachi H8 and SH.

`target sh3 DEV'
`target sh3e DEV'
     Hitachi SH-3 and SH-3E target systems.

   When you select remote debugging to a Hitachi SH, H8/300, or H8/500
board, the `load' command downloads your program to the Hitachi board
and also opens it as the current executable target for GDB on your host
(like the `file' command).

   GDB needs to know these things to talk to your Hitachi SH, H8/300,
or H8/500:

  1. that you want to use `target hms', the remote debugging interface
     for Hitachi microprocessors, or `target e7000', the in-circuit
     emulator for the Hitachi SH and the Hitachi 300H.  (`target hms' is
     the default when GDB is configured specifically for the Hitachi SH,
     H8/300, or H8/500.)

  2. what serial device connects your host to your Hitachi board (the
     first serial device available on your host is the default).

  3. what speed to use over the serial device.

* Menu:

* Hitachi Boards::      Connecting to Hitachi boards.
* Hitachi ICE::         Using the E7000 In-Circuit Emulator.
* Hitachi Special::     Special GDB commands for Hitachi micros.


File: gdb.info,  Node: Hitachi Boards,  Next: Hitachi ICE,  Up: H8/300

Connecting to Hitachi boards
............................

   Use the special `GDB' command `device PORT' if you need to
explicitly set the serial device.  The default PORT is the first
available port on your host.  This is only necessary on Unix hosts,
where it is typically something like `/dev/ttya'.

   `GDB' has another special command to set the communications speed:
`speed BPS'.  This command also is only used from Unix hosts; on DOS
hosts, set the line speed as usual from outside GDB with the DOS `mode'
command (for instance, `mode com2:9600,n,8,1,p' for a 9600bps
connection).

   The `device' and `speed' commands are available only when you use a
Unix host to debug your Hitachi microprocessor programs.  If you use a
DOS host, GDB depends on an auxiliary terminate-and-stay-resident
program called `asynctsr' to communicate with the development board
through a PC serial port.  You must also use the DOS `mode' command to
set up the serial port on the DOS side.

   The following sample session illustrates the steps needed to start a
program under GDB control on an H8/300.  The example uses a sample
H8/300 program called `t.x'.  The procedure is the same for the Hitachi
SH and the H8/500.

   First hook up your development board.  In this example, we use a
board attached to serial port `COM2'; if you use a different serial
port, substitute its name in the argument of the `mode' command.  When
you call `asynctsr', the auxiliary comms program used by the debugger,
you give it just the numeric part of the serial port's name; for
example, `asyncstr 2' below runs `asyncstr' on `COM2'.

     C:\H8300\TEST> asynctsr 2
     C:\H8300\TEST> mode com2:9600,n,8,1,p
     
     Resident portion of MODE loaded
     
     COM2: 9600, n, 8, 1, p

     _Warning:_ We have noticed a bug in PC-NFS that conflicts with
     `asynctsr'.  If you also run PC-NFS on your DOS host, you may need
     to disable it, or even boot without it, to use `asynctsr' to
     control your development board.

   Now that serial communications are set up, and the development board
is connected, you can start up GDB.  Call `gdb' with the name of your
program as the argument.  `GDB' prompts you, as usual, with the prompt
`(gdb)'.  Use two special commands to begin your debugging session:
`target hms' to specify cross-debugging to the Hitachi board, and the
`load' command to download your program to the board.  `load' displays
the names of the program's sections, and a `*' for each 2K of data
downloaded.  (If you want to refresh GDB data on symbols or on the
executable file without downloading, use the GDB commands `file' or
`symbol-file'.  These commands, and `load' itself, are described in
*Note Commands to specify files: Files.)

     (eg-C:\H8300\TEST) gdb t.x
     GDB is free software and you are welcome to distribute copies
      of it under certain conditions; type "show copying" to see
      the conditions.
     There is absolutely no warranty for GDB; type "show warranty"
     for details.
     GDB 5.1.0.1, Copyright 1992 Free Software Foundation, Inc...
     (gdb) target hms
     Connected to remote H8/300 HMS system.
     (gdb) load t.x
     .text   : 0x8000 .. 0xabde ***********
     .data   : 0xabde .. 0xad30 *
     .stack  : 0xf000 .. 0xf014 *

   At this point, you're ready to run or debug your program.  From here
on, you can use all the usual GDB commands.  The `break' command sets
breakpoints; the `run' command starts your program; `print' or `x'
display data; the `continue' command resumes execution after stopping
at a breakpoint.  You can use the `help' command at any time to find
out more about GDB commands.

   Remember, however, that _operating system_ facilities aren't
available on your development board; for example, if your program hangs,
you can't send an interrupt--but you can press the RESET switch!

   Use the RESET button on the development board
   * to interrupt your program (don't use `ctl-C' on the DOS host--it
     has no way to pass an interrupt signal to the development board);
     and

   * to return to the GDB command prompt after your program finishes
     normally.  The communications protocol provides no other way for
     GDB to detect program completion.

   In either case, GDB sees the effect of a RESET on the development
board as a "normal exit" of your program.


File: gdb.info,  Node: Hitachi ICE,  Next: Hitachi Special,  Prev: Hitachi Boards,  Up: H8/300

Using the E7000 in-circuit emulator
...................................

   You can use the E7000 in-circuit emulator to develop code for either
the Hitachi SH or the H8/300H.  Use one of these forms of the `target
e7000' command to connect GDB to your E7000:

`target e7000 PORT SPEED'
     Use this form if your E7000 is connected to a serial port.  The
     PORT argument identifies what serial port to use (for example,
     `com2').  The third argument is the line speed in bits per second
     (for example, `9600').

`target e7000 HOSTNAME'
     If your E7000 is installed as a host on a TCP/IP network, you can
     just specify its hostname; GDB uses `telnet' to connect.


File: gdb.info,  Node: Hitachi Special,  Prev: Hitachi ICE,  Up: H8/300

Special GDB commands for Hitachi micros
.......................................

   Some GDB commands are available only for the H8/300:

`set machine h8300'
`set machine h8300h'
     Condition GDB for one of the two variants of the H8/300
     architecture with `set machine'.  You can use `show machine' to
     check which variant is currently in effect.


File: gdb.info,  Node: H8/500,  Next: i960,  Prev: H8/300,  Up: Embedded Processors

H8/500
------

`set memory MOD'
`show memory'
     Specify which H8/500 memory model (MOD) you are using with `set
     memory'; check which memory model is in effect with `show memory'.
     The accepted values for MOD are `small', `big', `medium', and
     `compact'.


File: gdb.info,  Node: i960,  Next: M32R/D,  Prev: H8/500,  Up: Embedded Processors

Intel i960
----------

`target mon960 DEV'
     MON960 monitor for Intel i960.

`target nindy DEVICENAME'
     An Intel 960 board controlled by a Nindy Monitor.  DEVICENAME is
     the name of the serial device to use for the connection, e.g.
     `/dev/ttya'.

   "Nindy" is a ROM Monitor program for Intel 960 target systems.  When
GDB is configured to control a remote Intel 960 using Nindy, you can
tell GDB how to connect to the 960 in several ways:

   * Through command line options specifying serial port, version of the
     Nindy protocol, and communications speed;

   * By responding to a prompt on startup;

   * By using the `target' command at any point during your GDB
     session.  *Note Commands for managing targets: Target Commands.


   With the Nindy interface to an Intel 960 board, `load' downloads
FILENAME to the 960 as well as adding its symbols in GDB.

* Menu:

* Nindy Startup::               Startup with Nindy
* Nindy Options::               Options for Nindy
* Nindy Reset::                 Nindy reset command


File: gdb.info,  Node: Nindy Startup,  Next: Nindy Options,  Up: i960

Startup with Nindy
..................

   If you simply start `gdb' without using any command-line options,
you are prompted for what serial port to use, _before_ you reach the
ordinary GDB prompt:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Respond to the prompt with whatever suffix (after `/dev/tty')
identifies the serial port you want to use.  You can, if you choose,
simply start up with no Nindy connection by responding to the prompt
with an empty line.  If you do this and later wish to attach to Nindy,
use `target' (*note Commands for managing targets: Target Commands.).


File: gdb.info,  Node: Nindy Options,  Next: Nindy Reset,  Prev: Nindy Startup,  Up: i960

Options for Nindy
.................

   These are the startup options for beginning your GDB session with a
Nindy-960 board attached:

`-r PORT'
     Specify the serial port name of a serial interface to be used to
     connect to the target system.  This option is only available when
     GDB is configured for the Intel 960 target architecture.  You may
     specify PORT as any of: a full pathname (e.g. `-r /dev/ttya'), a
     device name in `/dev' (e.g. `-r ttya'), or simply the unique
     suffix for a specific `tty' (e.g. `-r a').

`-O'
     (An uppercase letter "O", not a zero.)  Specify that GDB should use
     the "old" Nindy monitor protocol to connect to the target system.
     This option is only available when GDB is configured for the Intel
     960 target architecture.

          _Warning:_ if you specify `-O', but are actually trying to
          connect to a target system that expects the newer protocol,
          the connection fails, appearing to be a speed mismatch.  GDB
          repeatedly attempts to reconnect at several different line
          speeds.  You can abort this process with an interrupt.

`-brk'
     Specify that GDB should first send a `BREAK' signal to the target
     system, in an attempt to reset it, before connecting to a Nindy
     target.

          _Warning:_ Many target systems do not have the hardware that
          this requires; it only works with a few boards.

   The standard `-b' option controls the line speed used on the serial
port.


File: gdb.info,  Node: Nindy Reset,  Prev: Nindy Options,  Up: i960

Nindy reset command
...................

`reset'
     For a Nindy target, this command sends a "break" to the remote
     target system; this is only useful if the target has been equipped
     with a circuit to perform a hard reset (or some other interesting
     action) when a break is detected.


File: gdb.info,  Node: M32R/D,  Next: M68K,  Prev: i960,  Up: Embedded Processors

Mitsubishi M32R/D
-----------------

`target m32r DEV'
     Mitsubishi M32R/D ROM monitor.


File: gdb.info,  Node: M68K,  Next: M88K,  Prev: M32R/D,  Up: Embedded Processors

M68k
----

   The Motorola m68k configuration includes ColdFire support, and
target command for the following ROM monitors.

`target abug DEV'
     ABug ROM monitor for M68K.

`target cpu32bug DEV'
     CPU32BUG monitor, running on a CPU32 (M68K) board.

`target dbug DEV'
     dBUG ROM monitor for Motorola ColdFire.

`target est DEV'
     EST-300 ICE monitor, running on a CPU32 (M68K) board.

`target rom68k DEV'
     ROM 68K monitor, running on an M68K IDP board.

   If GDB is configured with `m68*-ericsson-*', it will instead have
only a single special target command:

`target es1800 DEV'
     ES-1800 emulator for M68K.

   [context?]

`target rombug DEV'
     ROMBUG ROM monitor for OS/9000.


File: gdb.info,  Node: M88K,  Next: MIPS Embedded,  Prev: M68K,  Up: Embedded Processors

M88K
----

`target bug DEV'
     BUG monitor, running on a MVME187 (m88k) board.


File: gdb.info,  Node: MIPS Embedded,  Next: PA,  Prev: M88K,  Up: Embedded Processors

MIPS Embedded
-------------

   GDB can use the MIPS remote debugging protocol to talk to a MIPS
board attached to a serial line.  This is available when you configure
GDB with `--target=mips-idt-ecoff'.

   Use these GDB commands to specify the connection to your target
board:

`target mips PORT'
     To run a program on the board, start up `gdb' with the name of
     your program as the argument.  To connect to the board, use the
     command `target mips PORT', where PORT is the name of the serial
     port connected to the board.  If the program has not already been
     downloaded to the board, you may use the `load' command to
     download it.  You can then use all the usual GDB commands.

     For example, this sequence connects to the target board through a
     serial port, and loads and runs a program called PROG through the
     debugger:

          host$ gdb PROG
          GDB is free software and ...
          (gdb) target mips /dev/ttyb
          (gdb) load PROG
          (gdb) run

`target mips HOSTNAME:PORTNUMBER'
     On some GDB host configurations, you can specify a TCP connection
     (for instance, to a serial line managed by a terminal
     concentrator) instead of a serial port, using the syntax
     `HOSTNAME:PORTNUMBER'.

`target pmon PORT'
     PMON ROM monitor.

`target ddb PORT'
     NEC's DDB variant of PMON for Vr4300.

`target lsi PORT'
     LSI variant of PMON.

`target r3900 DEV'
     Densan DVE-R3900 ROM monitor for Toshiba R3900 Mips.

`target array DEV'
     Array Tech LSI33K RAID controller board.

GDB also supports these special commands for MIPS targets:

`set processor ARGS'
`show processor'
     Use the `set processor' command to set the type of MIPS processor
     when you want to access processor-type-specific registers.  For
     example, `set processor R3041' tells GDB to use the CPU registers
     appropriate for the 3041 chip.  Use the `show processor' command
     to see what MIPS processor GDB is using.  Use the `info reg'
     command to see what registers GDB is using.

`set mipsfpu double'
`set mipsfpu single'
`set mipsfpu none'
`show mipsfpu'
     If your target board does not support the MIPS floating point
     coprocessor, you should use the command `set mipsfpu none' (if you
     need this, you may wish to put the command in your GDB init file).
     This tells GDB how to find the return value of functions which
     return floating point values.  It also allows GDB to avoid saving
     the floating point registers when calling functions on the board.
     If you are using a floating point coprocessor with only single
     precision floating point support, as on the R4650 processor, use
     the command `set mipsfpu single'.  The default double precision
     floating point coprocessor may be selected using `set mipsfpu
     double'.

     In previous versions the only choices were double precision or no
     floating point, so `set mipsfpu on' will select double precision
     and `set mipsfpu off' will select no floating point.

     As usual, you can inquire about the `mipsfpu' variable with `show
     mipsfpu'.

`set remotedebug N'
`show remotedebug'
     You can see some debugging information about communications with
     the board by setting the `remotedebug' variable.  If you set it to
     `1' using `set remotedebug 1', every packet is displayed.  If you
     set it to `2', every character is displayed.  You can check the
     current value at any time with the command `show remotedebug'.

`set timeout SECONDS'
`set retransmit-timeout SECONDS'
`show timeout'
`show retransmit-timeout'
     You can control the timeout used while waiting for a packet, in
     the MIPS remote protocol, with the `set timeout SECONDS' command.
     The default is 5 seconds.  Similarly, you can control the timeout
     used while waiting for an acknowledgement of a packet with the `set
     retransmit-timeout SECONDS' command.  The default is 3 seconds.
     You can inspect both values with `show timeout' and `show
     retransmit-timeout'.  (These commands are _only_ available when
     GDB is configured for `--target=mips-idt-ecoff'.)

     The timeout set by `set timeout' does not apply when GDB is
     waiting for your program to stop.  In that case, GDB waits forever
     because it has no way of knowing how long the program is going to
     run before stopping.


File: gdb.info,  Node: PowerPC,  Next: SH,  Prev: PA,  Up: Embedded Processors

PowerPC
-------

`target dink32 DEV'
     DINK32 ROM monitor.

`target ppcbug DEV'

`target ppcbug1 DEV'
     PPCBUG ROM monitor for PowerPC.

`target sds DEV'
     SDS monitor, running on a PowerPC board (such as Motorola's ADS).


File: gdb.info,  Node: PA,  Next: PowerPC,  Prev: MIPS Embedded,  Up: Embedded Processors

HP PA Embedded
--------------

`target op50n DEV'
     OP50N monitor, running on an OKI HPPA board.

`target w89k DEV'
     W89K monitor, running on a Winbond HPPA board.


File: gdb.info,  Node: SH,  Next: Sparclet,  Prev: PowerPC,  Up: Embedded Processors

Hitachi SH
----------

`target hms DEV'
     A Hitachi SH board attached via serial line to your host.  Use
     special commands `device' and `speed' to control the serial line
     and the communications speed used.

`target e7000 DEV'
     E7000 emulator for Hitachi SH.

`target sh3 DEV'

`target sh3e DEV'
     Hitachi SH-3 and SH-3E target systems.


File: gdb.info,  Node: Sparclet,  Next: Sparclite,  Prev: SH,  Up: Embedded Processors

Tsqware Sparclet
----------------

   GDB enables developers to debug tasks running on Sparclet targets
from a Unix host.  GDB uses code that runs on both the Unix host and on
the Sparclet target.  The program `gdb' is installed and executed on
the Unix host.

`remotetimeout ARGS'
     GDB supports the option `remotetimeout'.  This option is set by
     the user, and  ARGS represents the number of seconds GDB waits for
     responses.

   When compiling for debugging, include the options `-g' to get debug
information and `-Ttext' to relocate the program to where you wish to
load it on the target.  You may also want to add the options `-n' or
`-N' in order to reduce the size of the sections.  Example:

     sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N

   You can use `objdump' to verify that the addresses are what you
intended:

     sparclet-aout-objdump --headers --syms prog

   Once you have set your Unix execution search path to find GDB, you
are ready to run GDB.  From your Unix host, run `gdb' (or
`sparclet-aout-gdb', depending on your installation).

   GDB comes up showing the prompt:

     (gdbslet)

* Menu:

* Sparclet File::                Setting the file to debug
* Sparclet Connection::          Connecting to Sparclet
* Sparclet Download::            Sparclet download
* Sparclet Execution::           Running and debugging


File: gdb.info,  Node: Sparclet File,  Next: Sparclet Connection,  Up: Sparclet

Setting file to debug
.....................

   The GDB command `file' lets you choose with program to debug.

     (gdbslet) file prog

   GDB then attempts to read the symbol table of `prog'.  GDB locates
the file by searching the directories listed in the command search path.
If the file was compiled with debug information (option "-g"), source
files will be searched as well.  GDB locates the source files by
searching the directories listed in the directory search path (*note
Your program's environment: Environment.).  If it fails to find a file,
it displays a message such as:

     prog: No such file or directory.

   When this happens, add the appropriate directories to the search
paths with the GDB commands `path' and `dir', and execute the `target'
command again.


File: gdb.info,  Node: Sparclet Connection,  Next: Sparclet Download,  Prev: Sparclet File,  Up: Sparclet

Connecting to Sparclet
......................

   The GDB command `target' lets you connect to a Sparclet target.  To
connect to a target on serial port "`ttya'", type:

     (gdbslet) target sparclet /dev/ttya
     Remote target sparclet connected to /dev/ttya
     main () at ../prog.c:3

   GDB displays messages like these:

     Connected to ttya.


File: gdb.info,  Node: Sparclet Download,  Next: Sparclet Execution,  Prev: Sparclet Connection,  Up: Sparclet

Sparclet download
.................

   Once connected to the Sparclet target, you can use the GDB `load'
command to download the file from the host to the target.  The file
name and load offset should be given as arguments to the `load' command.
Since the file format is aout, the program must be loaded to the
starting address.  You can use `objdump' to find out what this value
is.  The load offset is an offset which is added to the VMA (virtual
memory address) of each of the file's sections.  For instance, if the
program `prog' was linked to text address 0x1201000, with data at
0x12010160 and bss at 0x12010170, in GDB, type:

     (gdbslet) load prog 0x12010000
     Loading section .text, size 0xdb0 vma 0x12010000

   If the code is loaded at a different address then what the program
was linked to, you may need to use the `section' and `add-symbol-file'
commands to tell GDB where to map the symbol table.


File: gdb.info,  Node: Sparclet Execution,  Prev: Sparclet Download,  Up: Sparclet

Running and debugging
.....................

   You can now begin debugging the task using GDB's execution control
commands, `b', `step', `run', etc.  See the GDB manual for the list of
commands.

     (gdbslet) b main
     Breakpoint 1 at 0x12010000: file prog.c, line 3.
     (gdbslet) run
     Starting program: prog
     Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
     3        char *symarg = 0;
     (gdbslet) step
     4        char *execarg = "hello!";
     (gdbslet)


File: gdb.info,  Node: Sparclite,  Next: ST2000,  Prev: Sparclet,  Up: Embedded Processors

Fujitsu Sparclite
-----------------

`target sparclite DEV'
     Fujitsu sparclite boards, used only for the purpose of loading.
     You must use an additional command to debug the program.  For
     example: target remote DEV using GDB standard remote protocol.


File: gdb.info,  Node: ST2000,  Next: Z8000,  Prev: Sparclite,  Up: Embedded Processors

Tandem ST2000
-------------

   GDB may be used with a Tandem ST2000 phone switch, running Tandem's
STDBUG protocol.

   To connect your ST2000 to the host system, see the manufacturer's
manual.  Once the ST2000 is physically attached, you can run:

     target st2000 DEV SPEED

to establish it as your debugging environment.  DEV is normally the
name of a serial device, such as `/dev/ttya', connected to the ST2000
via a serial line.  You can instead specify DEV as a TCP connection
(for example, to a serial line attached via a terminal concentrator)
using the syntax `HOSTNAME:PORTNUMBER'.

   The `load' and `attach' commands are _not_ defined for this target;
you must load your program into the ST2000 as you normally would for
standalone operation.  GDB reads debugging information (such as
symbols) from a separate, debugging version of the program available on
your host computer.

   These auxiliary GDB commands are available to help you with the
ST2000 environment:

`st2000 COMMAND'
     Send a COMMAND to the STDBUG monitor.  See the manufacturer's
     manual for available commands.

`connect'
     Connect the controlling terminal to the STDBUG command monitor.
     When you are done interacting with STDBUG, typing either of two
     character sequences gets you back to the GDB command prompt:
     `<RET>~.' (Return, followed by tilde and period) or `<RET>~<C-d>'
     (Return, followed by tilde and control-D).


File: gdb.info,  Node: Z8000,  Prev: ST2000,  Up: Embedded Processors

Zilog Z8000
-----------

   When configured for debugging Zilog Z8000 targets, GDB includes a
Z8000 simulator.

   For the Z8000 family, `target sim' simulates either the Z8002 (the
unsegmented variant of the Z8000 architecture) or the Z8001 (the
segmented variant).  The simulator recognizes which architecture is
appropriate by inspecting the object code.

`target sim ARGS'
     Debug programs on a simulated CPU.  If the simulator supports setup
     options, specify them via ARGS.

After specifying this target, you can debug programs for the simulated
CPU in the same style as programs for your host computer; use the
`file' command to load a new program image, the `run' command to run
your program, and so on.

   As well as making available all the usual machine registers (*note
Registers: Registers.), the Z8000 simulator provides three additional
items of information as specially named registers:

`cycles'
     Counts clock-ticks in the simulator.

`insts'
     Counts instructions run in the simulator.

`time'
     Execution time in 60ths of a second.

   You can refer to these values in GDB expressions with the usual
conventions; for example, `b fputc if $cycles>5000' sets a conditional
breakpoint that suspends only after at least 5000 simulated clock ticks.


File: gdb.info,  Node: Architectures,  Prev: Embedded Processors,  Up: Configurations

Architectures
=============

   This section describes characteristics of architectures that affect
all uses of GDB with the architecture, both native and cross.

* Menu:

* A29K::
* Alpha::
* MIPS::


File: gdb.info,  Node: A29K,  Next: Alpha,  Up: Architectures

A29K
----

`set rstack_high_address ADDRESS'
     On AMD 29000 family processors, registers are saved in a separate
     "register stack".  There is no way for GDB to determine the extent
     of this stack.  Normally, GDB just assumes that the stack is
     "large enough".  This may result in GDB referencing memory
     locations that do not exist.  If necessary, you can get around
     this problem by specifying the ending address of the register
     stack with the `set rstack_high_address' command.  The argument
     should be an address, which you probably want to precede with `0x'
     to specify in hexadecimal.

`show rstack_high_address'
     Display the current limit of the register stack, on AMD 29000
     family processors.


File: gdb.info,  Node: Alpha,  Next: MIPS,  Prev: A29K,  Up: Architectures

Alpha
-----

   See the following section.


File: gdb.info,  Node: MIPS,  Prev: Alpha,  Up: Architectures

MIPS
----

   Alpha- and MIPS-based computers use an unusual stack frame, which
sometimes requires GDB to search backward in the object code to find
the beginning of a function.

   To improve response time (especially for embedded applications, where
GDB may be restricted to a slow serial line for this search) you may
want to limit the size of this search, using one of these commands:

`set heuristic-fence-post LIMIT'
     Restrict GDB to examining at most LIMIT bytes in its search for
     the beginning of a function.  A value of 0 (the default) means
     there is no limit.  However, except for 0, the larger the limit
     the more bytes `heuristic-fence-post' must search and therefore
     the longer it takes to run.

`show heuristic-fence-post'
     Display the current limit.

These commands are available _only_ when GDB is configured for
debugging programs on Alpha or MIPS processors.


File: gdb.info,  Node: Controlling GDB,  Next: Sequences,  Prev: Configurations,  Up: Top

Controlling GDB
***************

   You can alter the way GDB interacts with you by using the `set'
command.  For commands controlling how GDB displays data, see *Note
Print settings: Print Settings.  Other settings are described here.

* Menu:

* Prompt::                      Prompt
* Editing::                     Command editing
* History::                     Command history
* Screen Size::                 Screen size
* Numbers::                     Numbers
* Messages/Warnings::           Optional warnings and messages
* Debugging Output::            Optional messages about internal happenings


File: gdb.info,  Node: Prompt,  Next: Editing,  Up: Controlling GDB

Prompt
======

   GDB indicates its readiness to read a command by printing a string
called the "prompt".  This string is normally `(gdb)'.  You can change
the prompt string with the `set prompt' command.  For instance, when
debugging GDB with GDB, it is useful to change the prompt in one of the
GDB sessions so that you can always tell which one you are talking to.

   _Note:_  `set prompt' does not add a space for you after the prompt
you set.  This allows you to set a prompt which ends in a space or a
prompt that does not.

`set prompt NEWPROMPT'
     Directs GDB to use NEWPROMPT as its prompt string henceforth.

`show prompt'
     Prints a line of the form: `Gdb's prompt is: YOUR-PROMPT'


File: gdb.info,  Node: Editing,  Next: History,  Prev: Prompt,  Up: Controlling GDB

Command editing
===============

   GDB reads its input commands via the "readline" interface.  This GNU
library provides consistent behavior for programs which provide a
command line interface to the user.  Advantages are GNU Emacs-style or
"vi"-style inline editing of commands, `csh'-like history substitution,
and a storage and recall of command history across debugging sessions.

   You may control the behavior of command line editing in GDB with the
command `set'.

`set editing'
`set editing on'
     Enable command line editing (enabled by default).

`set editing off'
     Disable command line editing.

`show editing'
     Show whether command line editing is enabled.


File: gdb.info,  Node: History,  Next: Screen Size,  Prev: Editing,  Up: Controlling GDB

Command history
===============

   GDB can keep track of the commands you type during your debugging
sessions, so that you can be certain of precisely what happened.  Use
these commands to manage the GDB command history facility.

`set history filename FNAME'
     Set the name of the GDB command history file to FNAME.  This is
     the file where GDB reads an initial command history list, and
     where it writes the command history from this session when it
     exits.  You can access this list through history expansion or
     through the history command editing characters listed below.  This
     file defaults to the value of the environment variable
     `GDBHISTFILE', or to `./.gdb_history' (`./_gdb_history' on MS-DOS)
     if this variable is not set.

`set history save'
`set history save on'
     Record command history in a file, whose name may be specified with
     the `set history filename' command.  By default, this option is
     disabled.

`set history save off'
     Stop recording command history in a file.

`set history size SIZE'
     Set the number of commands which GDB keeps in its history list.
     This defaults to the value of the environment variable `HISTSIZE',
     or to 256 if this variable is not set.

   History expansion assigns special meaning to the character `!'.

   Since `!' is also the logical not operator in C, history expansion
is off by default. If you decide to enable history expansion with the
`set history expansion on' command, you may sometimes need to follow
`!' (when it is used as logical not, in an expression) with a space or
a tab to prevent it from being expanded.  The readline history
facilities do not attempt substitution on the strings `!=' and `!(',
even when history expansion is enabled.

   The commands to control history expansion are:

`set history expansion on'
`set history expansion'
     Enable history expansion.  History expansion is off by default.

`set history expansion off'
     Disable history expansion.

     The readline code comes with more complete documentation of
     editing and history expansion features.  Users unfamiliar with GNU
     Emacs or `vi' may wish to read it.

`show history'
`show history filename'
`show history save'
`show history size'
`show history expansion'
     These commands display the state of the GDB history parameters.
     `show history' by itself displays all four states.

`show commands'
     Display the last ten commands in the command history.

`show commands N'
     Print ten commands centered on command number N.

`show commands +'
     Print ten commands just after the commands last printed.


File: gdb.info,  Node: Screen Size,  Next: Numbers,  Prev: History,  Up: Controlling GDB

Screen size
===========

   Certain commands to GDB may produce large amounts of information
output to the screen.  To help you read all of it, GDB pauses and asks
you for input at the end of each page of output.  Type <RET> when you
want to continue the output, or `q' to discard the remaining output.
Also, the screen width setting determines when to wrap lines of output.
Depending on what is being printed, GDB tries to break the line at a
readable place, rather than simply letting it overflow onto the
following line.

   Normally GDB knows the size of the screen from the terminal driver
software.  For example, on Unix GDB uses the termcap data base together
with the value of the `TERM' environment variable and the `stty rows'
and `stty cols' settings.  If this is not correct, you can override it
with the `set height' and `set width' commands:

`set height LPP'
`show height'
`set width CPL'
`show width'
     These `set' commands specify a screen height of LPP lines and a
     screen width of CPL characters.  The associated `show' commands
     display the current settings.

     If you specify a height of zero lines, GDB does not pause during
     output no matter how long the output is.  This is useful if output
     is to a file or to an editor buffer.

     Likewise, you can specify `set width 0' to prevent GDB from
     wrapping its output.


File: gdb.info,  Node: Numbers,  Next: Messages/Warnings,  Prev: Screen Size,  Up: Controlling GDB

Numbers
=======

   You can always enter numbers in octal, decimal, or hexadecimal in
GDB by the usual conventions: octal numbers begin with `0', decimal
numbers end with `.', and hexadecimal numbers begin with `0x'.  Numbers
that begin with none of these are, by default, entered in base 10;
likewise, the default display for numbers--when no particular format is
specified--is base 10.  You can change the default base for both input
and output with the `set radix' command.

`set input-radix BASE'
     Set the default base for numeric input.  Supported choices for
     BASE are decimal 8, 10, or 16.  BASE must itself be specified
     either unambiguously or using the current default radix; for
     example, any of

          set radix 012
          set radix 10.
          set radix 0xa

     sets the base to decimal.  On the other hand, `set radix 10'
     leaves the radix unchanged no matter what it was.

`set output-radix BASE'
     Set the default base for numeric display.  Supported choices for
     BASE are decimal 8, 10, or 16.  BASE must itself be specified
     either unambiguously or using the current default radix.

`show input-radix'
     Display the current default base for numeric input.

`show output-radix'
     Display the current default base for numeric display.

